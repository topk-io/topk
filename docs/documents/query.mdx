---
title: "Query documents"
description: "Use the `query` method to search for documents."
---

import Support from "/snippets/support.mdx";

TopK provides a SQL-inspired syntax for querying documents. It features built-in **semantic search**, **text search**, **vector search**, and metadata **filtering** capabilities.

With TopK's declarative query builder, you can easily select fields, chain filters, and apply vector/text search in a composable manner.

## Select expressions

The `select()` method can be used to select fields from documents. It can be used to select specific fields, rename fields,
or include computed fields using [function expressions](#function-expressions).

<CodeGroup>

```python Python
from topk_sdk.query import select, field

docs = client.collection("books").query(
    select(
        "title",
        year=field("published_year") # renamed field
    )
)
```


```js Javascript
import { select, field } from "topk-js/query";

const docs = await client.collection("books").query(
  select({
    title: field("title"),
    year: field("published_year"), // renamed field
  })
);
```

</CodeGroup>

### Function expressions

Function expressions are computed fields that can be included in your query results. TopK currently supports three main function expressions:

- `bm25_score()`: Calculates relevance scores using the BM25 algorithm for text search
- `vector_distance(field, vector)`: Computes distance between vectors for vector search
- `semantic_similarity(field, query)`: Measures semantic similarity between text and embeddings

#### BM25 Score

The BM25 score is a relevance score that can be used to score documents based on their text content.

To use the `fn.bm25_score()` in your query, you **must** include a `match` predicate in your query filter stage.

<Warning>
  To use the `fn.bm25_score()` function, you **must** have a [**keyword index**](http://docs.topk.io/collections/create#keyword-index) defined in your collection schema.
</Warning>

<CodeGroup>

```python Python
from topk_sdk.query import select, fn, match

docs = client.collection("books").query(
    select(
        "title",
        text_score=fn.bm25_score()
    )
    .filter(match("Good")) # must include a match predicate
    .topk(field("text_score"), 10)
)

# Example result:
[
  {
    "_id": "1",
    "title": "Good Night, Bat! Good Morning, Squirrel!",
    "text_score": 0.2447269707918167
  },
  {
    "_id": "2",
    "title": "Good Girl, Bad Blood",
    "text_score": 0.20035339891910553
  }
]
```


```js Javascript
import { select, field, fn, match } from "topk-js/query";

const results = await client.collection("books").query(
  select({
    title: field("title"),
    text_score: fn.bm25Score(),
  })
    .filter(match("Good"))
    .topk(field("text_score"), 10)
);

// Example result:
[
  {
    _id: '1',
    title: 'Good Night, Bat! Good Morning, Squirrel!'
    text_score: 0.2447269707918167,
  },
  {
    _id: '2',
    title: 'Good Girl, Bad Blood',
    text_score: 0.20035339891910553
  }
]
```

</CodeGroup>

#### Vector distance

The `vector_distance` function is used to compute the distance between a query vector and a vector field in a collection.

To use the `vector_distance` function, you **must** have a [**vector index**](http://docs.topk.io/collections/create#vector-index) defined on the field you're computing the distance on.

<CodeGroup>

```python Python
from topk_sdk.query import select, fn

docs = client.collection("books").query(
    select(
        "title",
        title_similarity=fn.vector_distance("title_embedding", [0.1, 0.2, 0.3, ...])
         # embedding for "animal"
    )
    .topk(field("title_similarity"), 10)
)

# Example result:
[
  {
    "_id": "2",
    "title": "To Kill a Mockingbird",
    "title_similarity": 0.7484796643257141
  },
  {
    "_id": "1",
    "title": "The Catcher in the Rye",
    "title_similarity": 0.5471329569816589
  }
]
```

```js Javascript
import { select, field, fn } from "topk-js/query";

const docs = await client.collection("books").query(
  select({
    title: field("title"),
    title_similarity: fn.vectorDistance(
      "title_embedding",
      [0.1, 0.2, 0.3 /* embedding for "animal" */]
    ),
  })
);

// Example result:
[
  {
    _id: '2',
    title: 'To Kill a Mockingbird',
    title_similarity: 0.7484796643257141
  },
  {
    _id: '1'
    title: 'The Catcher in the Rye',
    title_similarity: 0.5471329569816589,
  }
]
```

</CodeGroup>


#### Semantic similarity

The `semantic_similarity` function is used to compute the similarity between a **text query** and a **text field** in a collection.

To use the `semantic_similarity` function, you **must** have a [**semantic index**](http://docs.topk.io/collections/create#semantic-index) defined on the field you're computing the similarity on.

<CodeGroup>

```python Python
from topk_sdk.query import select, fn

docs = client.collection("books").query(
    select(
        "title",
        title_similarity=fn.semantic_similarity("title", "animal")
    )
    .topk(field("title_similarity"), 10)
)

# Example result:
[
  {
    "_id": "2",
    "title": "To Kill a Mockingbird",
    "title_similarity": 0.7484796643257141
  },
  {
    "_id": "1",
    "title": "The Catcher in the Rye",
    "title_similarity": 0.5471329569816589
  }
]
```

```js Javascript
import { select, field, fn } from "topk-js/query";

const docs = await client.collection("books").query(
  select({
    title: field("title"),
    title_similarity: fn.semanticSimilarity("title", "animal"),
  })
    .topk(field("title_similarity"), 10)
);

// Example result:
[
  {
    _id: '2',
    title: 'To Kill a Mockingbird',
    title_similarity: 0.7484796643257141
  },
  {
    _id: '1',
    title: 'The Catcher in the Rye',
    title_similarity: 0.5471329569816589
  }
]
```

</CodeGroup>

### Advanced select expressions

TopK doesn't only let you select static fields from your documents or computed fields using function expressions.
You can also use TopK powerful expression language to select fields by chaining arbitrary logical expressions:

<CodeGroup>

```python Python
select(
  weight_in_grams=field("weight").mul(1000),
  is_adult=field("age").gt(18),
  published_in_nineteenth_century=field("published_year") >= 1800 && field("published_year") < 1900,
)
```


```js Javascript
import { select, field } from "topk-js/query";

select({
  weight_in_grams: field("weight").mul(1000),
  is_adult: field("age").gt(18),
  published_in_nineteenth_century: field("published_year")
    .gte(1800)
    .and(field("published_year").lt(1900)),
});
```

</CodeGroup>

## Filtering

You can filter documents by **metadata**, **keywords**, **custom properties** computed inside `select()` (e.g. vector similarity or BM25 score) and more. Filter expressions support all comparison operators: `==`, `!=`, `>`, `>=`, `<`, `<=`, arithmetic operations: `+`, `-`, `*`, `/`, and boolean operators: `|` and `&`.

### Metadata filtering

<CodeGroup>

```python Python
.filter(
    field("published_year") > 1980
)
```


```js Javascript
.filter(field("published_year").gt(1980))
```

</CodeGroup>

### Keyword search

The `match()` function is the backbone of keyword search in TopK.
It allows you to search for documents that contain specific keywords or phrases.

You can configure the `match()` function to:
* Match on multiple terms
* Match only on specific fields
* Use weights to prioritize certain terms

Searching for a term like `"catcher"` in your documents is as simple as using the `match()` function in the filter stage of your query:

<CodeGroup>

```python Python
from topk_sdk.query import match

.filter(
    match("catcher")
)
```

```js Javascript
import { match } from "topk-js/query";

.filter(match("catcher"))
```

</CodeGroup>

#### Match multiple terms

The `match()` function can also be configured to match on specific fields.

### Multiple filters

You can combine metadata filtering and keyword search in a single query by stacking multiple filtering stages.

In the example below, we're searching for documents that contain the keyword "catcher" and were published in 1997, or documents that were published between 1920 and 1980.

<CodeGroup>

```python Python
.filter(
    match("catcher")
)
.filter(
    field("published_year") == 1997 || (field("published_year") >= 1920 && field("published_year") <= 1980)
)
```


```js Javascript
.filter(
  match("catcher")
)
.filter(
  field("published_year").eq(1997).or(field("published_year").gte(1920).and(field("published_year").lte(1980)))
)
```

</CodeGroup>

## Operators

When writing queries, you can use the following operators for field selection and filtering:

### Logical operators

#### and

The `and` operator can be used to combine multiple logical expressions.

<CodeGroup>

```python Python
.filter(
    field("published_year") == 1997 && field("title") == "The Catcher in the Rye"
)

# or

.filter(
    field("published_year").eq(1997).and(field("title").eq("The Catcher in the Rye"))
)
```


```js Javascript
.filter(
  field("published_year").eq(1997).and(field("title").eq("The Catcher in the Rye"))
)
```

</CodeGroup>

#### or

The `or` operator can be used to combine multiple logical expressions.

<CodeGroup>

```python Python
.filter(
    field("published_year") == 1997 || field("title") == "The Catcher in the Rye"
)

# or

.filter(
    field("published_year").eq(1997).or(field("title").eq("The Catcher in the Rye"))
)
```


```js Javascript
.filter(
  field("published_year").eq(1997).or(field("title").eq("The Catcher in the Rye"))
)
```

</CodeGroup>

### Comparison operators

#### eq

The `eq` operator can be used to match documents that have a field with a specific value.

<CodeGroup>

```python Python
.filter(
    field("published_year") == 1997
)

# or

.filter(
    field("published_year").eq(1997)
)
```

```js Javascript
.filter(field("published_year").eq(1997))
```

</CodeGroup>

#### ne

The `ne` operator can be used to match documents that have a field with a value that is not equal to a specific value.

<CodeGroup>

```python Python
.filter(
    field("published_year") != 1997
)

# or

.filter(
    field("published_year").ne(1997)
)
```

```js Javascript
.filter(field("published_year").ne(1997))
```

</CodeGroup>

#### gt

The `gt` operator can be used to match documents that have a field with a value greater than a specific value.

<CodeGroup>

```python Python
.filter(
    field("published_year") > 1997
)

# or

.filter(
    field("published_year").gt(1997)
)
```

```js Javascript
.filter(field("published_year").gt(1997))
```

</CodeGroup>

#### gte

The `gte` operator can be used to match documents that have a field with a value greater than or equal to a specific value.

<CodeGroup>

```python Python
.filter(
    field("published_year") >= 1997
)

# or

.filter(
    field("published_year").gte(1997)
)
```


```js Javascript
.filter(field("published_year").gte(1997))
```

</CodeGroup>

#### lt

The `lt` operator can be used to match documents that have a field with a value less than a specific value.

<CodeGroup>

```python Python
.filter(
    field("published_year") < 1997
)

# or

.filter(
    field("published_year").lt(1997)
)
```

```js Javascript
.filter(field("published_year").lt(1997))
```

</CodeGroup>

#### lte

The `lte` operator can be used to match documents that have a field with a value less than or equal to a specific value.

<CodeGroup>

```python Python
.filter(
    field("published_year") <= 1997
)

# or

.filter(
    field("published_year").lte(1997)
)
```

```js Javascript
.filter(field("published_year").lte(1997))
```

</CodeGroup>


#### starts_with

The `starts_with` operator can be used on string fields to match documents that start with a given prefix. This is especially
useful in multi-tenant applications where document IDs can be structured as `{tenant_id}/{document_id}` and `starts_with` can
then be used to scope the query to a specific tenant.

<CodeGroup>

```python Python
.filter(
    field("_id").starts_with("tenant_123/")
)
```


```js Javascript
.filter(field("_id").startsWith("tenant_123/"))
```

</CodeGroup>

#### contains

The `contains` operator can be used on string fields to match documents that include a specific substring. It is **case-sensitive** and is particularly useful in scenarios where you need to filter results based on a portion of a string.

<CodeGroup>

```python Python
.filter(
    field("title").contains("Catcher")
)
```


```typescript Javascript
.filter(field("title").contains("Catcher"))
```

</CodeGroup>

### Arithmetic operators

#### add

The `add` operator can be used to add two numbers.

<CodeGroup>

```python Python
.filter(
    field("published_year") + 1997
)

# or

.filter(
    field("published_year").add(1997)
)
```

```js Javascript
.filter(field("published_year").add(1997))
```

</CodeGroup>

#### sub

The `sub` operator can be used to subtract two numbers.

<CodeGroup>

```python Python
.filter(
    field("published_year") - 1997
)

# or

.filter(
    field("published_year").sub(1997)
)
```


```js Javascript
.filter(field("published_year").sub(1997))
```

</CodeGroup>

#### mul

The `mul` operator can be used to multiply two numbers.

<CodeGroup>

```python Python
.filter(
    field("published_year") * 1997
)

# or

.filter(
    field("published_year").mul(1997)
)
```

```js Javascript
.filter(field("published_year").mul(1997))
```

</CodeGroup>

#### div

The `div` operator can be used to divide two numbers.

<CodeGroup>

```python Python
.filter(
    field("published_year") / 1997
)

# or

.filter(
    field("published_year").div(1997)
)
```

```js Javascript
.filter(field("published_year").div(1997))
```

</CodeGroup>

### Unary operators

#### not

The `not` helper can be used to **negate** a logical expression. It takes an expression as an argument and inverts its logic.

<CodeGroup>

```python Python
from topk_sdk.query import field, not_

.filter(
    not_(field("title").contains("Catcher"))
)
```


```typescript Javascript
import { field, not } from "topk-js/query";

.filter(
    not(field("title").contains("Catcher"))
)
```

</CodeGroup>
#### is_null

The `is_null` operator can be used to match documents that have a field with a value that is `null`.

<CodeGroup>

```python Python
.filter(
    field("title").is_null()
)
```


```js Javascript
.filter(field("title").isNull())
```

</CodeGroup>

#### is_not_null

The `is_not_null` operator can be used to match documents that have a field with a value that is not `null`.

<CodeGroup>

```python Python
.filter(
    field("title").is_not_null()
)
```


```js Javascript
.filter(field("title").isNotNull())
```

</CodeGroup>

## Query collection

All queries are required to have a collection stage. Currently, we only support `topk` and `count` collectors.

### topk

Use the `topk()` method to return the top `k` results. The `topk` method accepts the following arguments:

<ParamField path="field" type="LogicalExpression" required={true}>
  The logical expression to sort the results by.
</ParamField>

<ParamField path="k" type="number" required={true}>
  The number of results to return.
</ParamField>

<ParamField path="asc" type="boolean" required={false}>
  Whether to sort the results in ascending order.
</ParamField>

To get the top 10 results ordered by the `title_similarity` field, you can use the following query:

<CodeGroup>

```python Python
# Return top 10 results order by `published_year` ascending
.topk(field("title_similarity"), 10, asc=True)
```


```typescript Javascript
// Return top 10 results order by `published_year` and ascending `true`
.topk(field("title_similarity"), 10, true)
```

</CodeGroup>

### count

Use the `count()` method to get the total number of documents matching the query. If there are no filters then `count` will return the total number of documents in the collection.

<CodeGroup>

```python Python
# Count the total number of documents in the collection
.count()
```


```js Javascript
// Count the total number of documents in the collection
.count()
```

</CodeGroup>

## Notes on writing queries

When writing queries, remember that they all require the `topk` or `count` method at the end.