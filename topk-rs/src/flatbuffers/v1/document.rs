// automatically generated by the FlatBuffers compiler, do not modify

// @generated

use core::cmp::Ordering;
use core::mem;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_LIST_VALUES: u8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_LIST_VALUES: u8 = 9;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_LIST_VALUES: [ListValues; 10] = [
    ListValues::NONE,
    ListValues::U8Values,
    ListValues::U32Values,
    ListValues::U64Values,
    ListValues::I8Values,
    ListValues::I32Values,
    ListValues::I64Values,
    ListValues::F32Values,
    ListValues::F64Values,
    ListValues::StringValues,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ListValues(pub u8);
#[allow(non_upper_case_globals)]
impl ListValues {
    pub const NONE: Self = Self(0);
    pub const U8Values: Self = Self(1);
    pub const U32Values: Self = Self(2);
    pub const U64Values: Self = Self(3);
    pub const I8Values: Self = Self(4);
    pub const I32Values: Self = Self(5);
    pub const I64Values: Self = Self(6);
    pub const F32Values: Self = Self(7);
    pub const F64Values: Self = Self(8);
    pub const StringValues: Self = Self(9);

    pub const ENUM_MIN: u8 = 0;
    pub const ENUM_MAX: u8 = 9;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::U8Values,
        Self::U32Values,
        Self::U64Values,
        Self::I8Values,
        Self::I32Values,
        Self::I64Values,
        Self::F32Values,
        Self::F64Values,
        Self::StringValues,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::U8Values => Some("U8Values"),
            Self::U32Values => Some("U32Values"),
            Self::U64Values => Some("U64Values"),
            Self::I8Values => Some("I8Values"),
            Self::I32Values => Some("I32Values"),
            Self::I64Values => Some("I64Values"),
            Self::F32Values => Some("F32Values"),
            Self::F64Values => Some("F64Values"),
            Self::StringValues => Some("StringValues"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for ListValues {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for ListValues {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for ListValues {
    type Output = ListValues;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for ListValues {
    type Scalar = u8;
    #[inline]
    fn to_little_endian(self) -> u8 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: u8) -> Self {
        let b = u8::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for ListValues {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        u8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for ListValues {}
pub struct ListValuesUnionTableOffset {}

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_SPARSE_VECTOR_VALUES: u8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_SPARSE_VECTOR_VALUES: u8 = 2;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_SPARSE_VECTOR_VALUES: [SparseVectorValues; 3] = [
    SparseVectorValues::NONE,
    SparseVectorValues::U8Values,
    SparseVectorValues::F32Values,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct SparseVectorValues(pub u8);
#[allow(non_upper_case_globals)]
impl SparseVectorValues {
    pub const NONE: Self = Self(0);
    pub const U8Values: Self = Self(1);
    pub const F32Values: Self = Self(2);

    pub const ENUM_MIN: u8 = 0;
    pub const ENUM_MAX: u8 = 2;
    pub const ENUM_VALUES: &'static [Self] = &[Self::NONE, Self::U8Values, Self::F32Values];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::U8Values => Some("U8Values"),
            Self::F32Values => Some("F32Values"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for SparseVectorValues {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for SparseVectorValues {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for SparseVectorValues {
    type Output = SparseVectorValues;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for SparseVectorValues {
    type Scalar = u8;
    #[inline]
    fn to_little_endian(self) -> u8 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: u8) -> Self {
        let b = u8::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for SparseVectorValues {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        u8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for SparseVectorValues {}
pub struct SparseVectorValuesUnionTableOffset {}

#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MIN_VALUE_UNION: u8 = 0;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
pub const ENUM_MAX_VALUE_UNION: u8 = 11;
#[deprecated(
    since = "2.0.0",
    note = "Use associated constants instead. This will no longer be generated in 2021."
)]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_VALUE_UNION: [ValueUnion; 12] = [
    ValueUnion::NONE,
    ValueUnion::Bool,
    ValueUnion::U32,
    ValueUnion::U64,
    ValueUnion::I32,
    ValueUnion::I64,
    ValueUnion::F32,
    ValueUnion::F64,
    ValueUnion::String,
    ValueUnion::Bytes,
    ValueUnion::List,
    ValueUnion::Struct,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ValueUnion(pub u8);
#[allow(non_upper_case_globals)]
impl ValueUnion {
    pub const NONE: Self = Self(0);
    pub const Bool: Self = Self(1);
    pub const U32: Self = Self(2);
    pub const U64: Self = Self(3);
    pub const I32: Self = Self(4);
    pub const I64: Self = Self(5);
    pub const F32: Self = Self(6);
    pub const F64: Self = Self(7);
    pub const String: Self = Self(8);
    pub const Bytes: Self = Self(9);
    pub const List: Self = Self(10);
    pub const Struct: Self = Self(11);

    pub const ENUM_MIN: u8 = 0;
    pub const ENUM_MAX: u8 = 11;
    pub const ENUM_VALUES: &'static [Self] = &[
        Self::NONE,
        Self::Bool,
        Self::U32,
        Self::U64,
        Self::I32,
        Self::I64,
        Self::F32,
        Self::F64,
        Self::String,
        Self::Bytes,
        Self::List,
        Self::Struct,
    ];
    /// Returns the variant's name or "" if unknown.
    pub fn variant_name(self) -> Option<&'static str> {
        match self {
            Self::NONE => Some("NONE"),
            Self::Bool => Some("Bool"),
            Self::U32 => Some("U32"),
            Self::U64 => Some("U64"),
            Self::I32 => Some("I32"),
            Self::I64 => Some("I64"),
            Self::F32 => Some("F32"),
            Self::F64 => Some("F64"),
            Self::String => Some("String"),
            Self::Bytes => Some("Bytes"),
            Self::List => Some("List"),
            Self::Struct => Some("Struct"),
            _ => None,
        }
    }
}
impl core::fmt::Debug for ValueUnion {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        if let Some(name) = self.variant_name() {
            f.write_str(name)
        } else {
            f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
        }
    }
}
impl<'a> flatbuffers::Follow<'a> for ValueUnion {
    type Inner = Self;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
        Self(b)
    }
}

impl flatbuffers::Push for ValueUnion {
    type Output = ValueUnion;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for ValueUnion {
    type Scalar = u8;
    #[inline]
    fn to_little_endian(self) -> u8 {
        self.0.to_le()
    }
    #[inline]
    #[allow(clippy::wrong_self_convention)]
    fn from_little_endian(v: u8) -> Self {
        let b = u8::from_le(v);
        Self(b)
    }
}

impl<'a> flatbuffers::Verifiable for ValueUnion {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        u8::run_verifier(v, pos)
    }
}

impl flatbuffers::SimpleToVerifyInSlice for ValueUnion {}
pub struct ValueUnionUnionTableOffset {}

pub enum BoolOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Bool<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Bool<'a> {
    type Inner = Bool<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> Bool<'a> {
    pub const VT_VALUE: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Bool { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args BoolArgs,
    ) -> flatbuffers::WIPOffset<Bool<'bldr>> {
        let mut builder = BoolBuilder::new(_fbb);
        builder.add_value(args.value);
        builder.finish()
    }

    #[inline]
    pub fn value(&self) -> bool {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe { self._tab.get::<bool>(Bool::VT_VALUE, Some(false)).unwrap() }
    }
}

impl flatbuffers::Verifiable for Bool<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<bool>("value", Self::VT_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct BoolArgs {
    pub value: bool,
}
impl<'a> Default for BoolArgs {
    #[inline]
    fn default() -> Self {
        BoolArgs { value: false }
    }
}

pub struct BoolBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> BoolBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_value(&mut self, value: bool) {
        self.fbb_.push_slot::<bool>(Bool::VT_VALUE, value, false);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> BoolBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        BoolBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<Bool<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for Bool<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("Bool");
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum U32Offset {}
#[derive(Copy, Clone, PartialEq)]

pub struct U32<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for U32<'a> {
    type Inner = U32<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> U32<'a> {
    pub const VT_VALUE: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        U32 { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args U32Args,
    ) -> flatbuffers::WIPOffset<U32<'bldr>> {
        let mut builder = U32Builder::new(_fbb);
        builder.add_value(args.value);
        builder.finish()
    }

    #[inline]
    pub fn value(&self) -> u32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe { self._tab.get::<u32>(U32::VT_VALUE, Some(0)).unwrap() }
    }
}

impl flatbuffers::Verifiable for U32<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<u32>("value", Self::VT_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct U32Args {
    pub value: u32,
}
impl<'a> Default for U32Args {
    #[inline]
    fn default() -> Self {
        U32Args { value: 0 }
    }
}

pub struct U32Builder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> U32Builder<'a, 'b, A> {
    #[inline]
    pub fn add_value(&mut self, value: u32) {
        self.fbb_.push_slot::<u32>(U32::VT_VALUE, value, 0);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> U32Builder<'a, 'b, A> {
        let start = _fbb.start_table();
        U32Builder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<U32<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for U32<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("U32");
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum U64Offset {}
#[derive(Copy, Clone, PartialEq)]

pub struct U64<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for U64<'a> {
    type Inner = U64<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> U64<'a> {
    pub const VT_VALUE: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        U64 { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args U64Args,
    ) -> flatbuffers::WIPOffset<U64<'bldr>> {
        let mut builder = U64Builder::new(_fbb);
        builder.add_value(args.value);
        builder.finish()
    }

    #[inline]
    pub fn value(&self) -> u64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe { self._tab.get::<u64>(U64::VT_VALUE, Some(0)).unwrap() }
    }
}

impl flatbuffers::Verifiable for U64<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<u64>("value", Self::VT_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct U64Args {
    pub value: u64,
}
impl<'a> Default for U64Args {
    #[inline]
    fn default() -> Self {
        U64Args { value: 0 }
    }
}

pub struct U64Builder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> U64Builder<'a, 'b, A> {
    #[inline]
    pub fn add_value(&mut self, value: u64) {
        self.fbb_.push_slot::<u64>(U64::VT_VALUE, value, 0);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> U64Builder<'a, 'b, A> {
        let start = _fbb.start_table();
        U64Builder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<U64<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for U64<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("U64");
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum I32Offset {}
#[derive(Copy, Clone, PartialEq)]

pub struct I32<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for I32<'a> {
    type Inner = I32<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> I32<'a> {
    pub const VT_VALUE: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        I32 { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args I32Args,
    ) -> flatbuffers::WIPOffset<I32<'bldr>> {
        let mut builder = I32Builder::new(_fbb);
        builder.add_value(args.value);
        builder.finish()
    }

    #[inline]
    pub fn value(&self) -> i32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe { self._tab.get::<i32>(I32::VT_VALUE, Some(0)).unwrap() }
    }
}

impl flatbuffers::Verifiable for I32<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i32>("value", Self::VT_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct I32Args {
    pub value: i32,
}
impl<'a> Default for I32Args {
    #[inline]
    fn default() -> Self {
        I32Args { value: 0 }
    }
}

pub struct I32Builder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> I32Builder<'a, 'b, A> {
    #[inline]
    pub fn add_value(&mut self, value: i32) {
        self.fbb_.push_slot::<i32>(I32::VT_VALUE, value, 0);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> I32Builder<'a, 'b, A> {
        let start = _fbb.start_table();
        I32Builder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<I32<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for I32<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("I32");
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum I64Offset {}
#[derive(Copy, Clone, PartialEq)]

pub struct I64<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for I64<'a> {
    type Inner = I64<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> I64<'a> {
    pub const VT_VALUE: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        I64 { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args I64Args,
    ) -> flatbuffers::WIPOffset<I64<'bldr>> {
        let mut builder = I64Builder::new(_fbb);
        builder.add_value(args.value);
        builder.finish()
    }

    #[inline]
    pub fn value(&self) -> i64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe { self._tab.get::<i64>(I64::VT_VALUE, Some(0)).unwrap() }
    }
}

impl flatbuffers::Verifiable for I64<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<i64>("value", Self::VT_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct I64Args {
    pub value: i64,
}
impl<'a> Default for I64Args {
    #[inline]
    fn default() -> Self {
        I64Args { value: 0 }
    }
}

pub struct I64Builder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> I64Builder<'a, 'b, A> {
    #[inline]
    pub fn add_value(&mut self, value: i64) {
        self.fbb_.push_slot::<i64>(I64::VT_VALUE, value, 0);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> I64Builder<'a, 'b, A> {
        let start = _fbb.start_table();
        I64Builder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<I64<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for I64<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("I64");
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum F32Offset {}
#[derive(Copy, Clone, PartialEq)]

pub struct F32<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for F32<'a> {
    type Inner = F32<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> F32<'a> {
    pub const VT_VALUE: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        F32 { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args F32Args,
    ) -> flatbuffers::WIPOffset<F32<'bldr>> {
        let mut builder = F32Builder::new(_fbb);
        builder.add_value(args.value);
        builder.finish()
    }

    #[inline]
    pub fn value(&self) -> f32 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe { self._tab.get::<f32>(F32::VT_VALUE, Some(0.0)).unwrap() }
    }
}

impl flatbuffers::Verifiable for F32<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<f32>("value", Self::VT_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct F32Args {
    pub value: f32,
}
impl<'a> Default for F32Args {
    #[inline]
    fn default() -> Self {
        F32Args { value: 0.0 }
    }
}

pub struct F32Builder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> F32Builder<'a, 'b, A> {
    #[inline]
    pub fn add_value(&mut self, value: f32) {
        self.fbb_.push_slot::<f32>(F32::VT_VALUE, value, 0.0);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> F32Builder<'a, 'b, A> {
        let start = _fbb.start_table();
        F32Builder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<F32<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for F32<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("F32");
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum F64Offset {}
#[derive(Copy, Clone, PartialEq)]

pub struct F64<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for F64<'a> {
    type Inner = F64<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> F64<'a> {
    pub const VT_VALUE: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        F64 { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args F64Args,
    ) -> flatbuffers::WIPOffset<F64<'bldr>> {
        let mut builder = F64Builder::new(_fbb);
        builder.add_value(args.value);
        builder.finish()
    }

    #[inline]
    pub fn value(&self) -> f64 {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe { self._tab.get::<f64>(F64::VT_VALUE, Some(0.0)).unwrap() }
    }
}

impl flatbuffers::Verifiable for F64<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<f64>("value", Self::VT_VALUE, false)?
            .finish();
        Ok(())
    }
}
pub struct F64Args {
    pub value: f64,
}
impl<'a> Default for F64Args {
    #[inline]
    fn default() -> Self {
        F64Args { value: 0.0 }
    }
}

pub struct F64Builder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> F64Builder<'a, 'b, A> {
    #[inline]
    pub fn add_value(&mut self, value: f64) {
        self.fbb_.push_slot::<f64>(F64::VT_VALUE, value, 0.0);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> F64Builder<'a, 'b, A> {
        let start = _fbb.start_table();
        F64Builder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<F64<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for F64<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("F64");
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum StringOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct String<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for String<'a> {
    type Inner = String<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> String<'a> {
    pub const VT_VALUE: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        String { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args StringArgs<'args>,
    ) -> flatbuffers::WIPOffset<String<'bldr>> {
        let mut builder = StringBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn value(&self) -> &'a str {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<&str>>(String::VT_VALUE, None)
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for String<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<&str>>("value", Self::VT_VALUE, true)?
            .finish();
        Ok(())
    }
}
pub struct StringArgs<'a> {
    pub value: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for StringArgs<'a> {
    #[inline]
    fn default() -> Self {
        StringArgs {
            value: None, // required field
        }
    }
}

pub struct StringBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> StringBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<&'b str>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(String::VT_VALUE, value);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> StringBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        StringBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<String<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(o, String::VT_VALUE, "value");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for String<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("String");
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum BytesOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Bytes<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Bytes<'a> {
    type Inner = Bytes<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> Bytes<'a> {
    pub const VT_VALUE: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Bytes { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args BytesArgs<'args>,
    ) -> flatbuffers::WIPOffset<Bytes<'bldr>> {
        let mut builder = BytesBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn value(&self) -> flatbuffers::Vector<'a, u8> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                    Bytes::VT_VALUE,
                    None,
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for Bytes<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                "value",
                Self::VT_VALUE,
                true,
            )?
            .finish();
        Ok(())
    }
}
pub struct BytesArgs<'a> {
    pub value: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for BytesArgs<'a> {
    #[inline]
    fn default() -> Self {
        BytesArgs {
            value: None, // required field
        }
    }
}

pub struct BytesBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> BytesBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Bytes::VT_VALUE, value);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> BytesBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        BytesBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<Bytes<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(o, Bytes::VT_VALUE, "value");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for Bytes<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("Bytes");
        ds.field("value", &self.value());
        ds.finish()
    }
}
pub enum U8ValuesOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct U8Values<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for U8Values<'a> {
    type Inner = U8Values<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> U8Values<'a> {
    pub const VT_VALUES: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        U8Values { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args U8ValuesArgs<'args>,
    ) -> flatbuffers::WIPOffset<U8Values<'bldr>> {
        let mut builder = U8ValuesBuilder::new(_fbb);
        if let Some(x) = args.values {
            builder.add_values(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn values(&self) -> flatbuffers::Vector<'a, u8> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                    U8Values::VT_VALUES,
                    None,
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for U8Values<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                "values",
                Self::VT_VALUES,
                true,
            )?
            .finish();
        Ok(())
    }
}
pub struct U8ValuesArgs<'a> {
    pub values: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for U8ValuesArgs<'a> {
    #[inline]
    fn default() -> Self {
        U8ValuesArgs {
            values: None, // required field
        }
    }
}

pub struct U8ValuesBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> U8ValuesBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_values(&mut self, values: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(U8Values::VT_VALUES, values);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> U8ValuesBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        U8ValuesBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<U8Values<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(o, U8Values::VT_VALUES, "values");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for U8Values<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("U8Values");
        ds.field("values", &self.values());
        ds.finish()
    }
}
pub enum U32ValuesOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct U32Values<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for U32Values<'a> {
    type Inner = U32Values<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> U32Values<'a> {
    pub const VT_VALUES: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        U32Values { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args U32ValuesArgs<'args>,
    ) -> flatbuffers::WIPOffset<U32Values<'bldr>> {
        let mut builder = U32ValuesBuilder::new(_fbb);
        if let Some(x) = args.values {
            builder.add_values(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn values(&self) -> flatbuffers::Vector<'a, u32> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(
                    U32Values::VT_VALUES,
                    None,
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for U32Values<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(
                "values",
                Self::VT_VALUES,
                true,
            )?
            .finish();
        Ok(())
    }
}
pub struct U32ValuesArgs<'a> {
    pub values: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
}
impl<'a> Default for U32ValuesArgs<'a> {
    #[inline]
    fn default() -> Self {
        U32ValuesArgs {
            values: None, // required field
        }
    }
}

pub struct U32ValuesBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> U32ValuesBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_values(&mut self, values: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u32>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(U32Values::VT_VALUES, values);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> U32ValuesBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        U32ValuesBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<U32Values<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(o, U32Values::VT_VALUES, "values");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for U32Values<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("U32Values");
        ds.field("values", &self.values());
        ds.finish()
    }
}
pub enum U64ValuesOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct U64Values<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for U64Values<'a> {
    type Inner = U64Values<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> U64Values<'a> {
    pub const VT_VALUES: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        U64Values { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args U64ValuesArgs<'args>,
    ) -> flatbuffers::WIPOffset<U64Values<'bldr>> {
        let mut builder = U64ValuesBuilder::new(_fbb);
        if let Some(x) = args.values {
            builder.add_values(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn values(&self) -> flatbuffers::Vector<'a, u64> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u64>>>(
                    U64Values::VT_VALUES,
                    None,
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for U64Values<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u64>>>(
                "values",
                Self::VT_VALUES,
                true,
            )?
            .finish();
        Ok(())
    }
}
pub struct U64ValuesArgs<'a> {
    pub values: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u64>>>,
}
impl<'a> Default for U64ValuesArgs<'a> {
    #[inline]
    fn default() -> Self {
        U64ValuesArgs {
            values: None, // required field
        }
    }
}

pub struct U64ValuesBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> U64ValuesBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_values(&mut self, values: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u64>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(U64Values::VT_VALUES, values);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> U64ValuesBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        U64ValuesBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<U64Values<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(o, U64Values::VT_VALUES, "values");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for U64Values<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("U64Values");
        ds.field("values", &self.values());
        ds.finish()
    }
}
pub enum I8ValuesOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct I8Values<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for I8Values<'a> {
    type Inner = I8Values<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> I8Values<'a> {
    pub const VT_VALUES: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        I8Values { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args I8ValuesArgs<'args>,
    ) -> flatbuffers::WIPOffset<I8Values<'bldr>> {
        let mut builder = I8ValuesBuilder::new(_fbb);
        if let Some(x) = args.values {
            builder.add_values(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn values(&self) -> flatbuffers::Vector<'a, i8> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i8>>>(
                    I8Values::VT_VALUES,
                    None,
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for I8Values<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i8>>>(
                "values",
                Self::VT_VALUES,
                true,
            )?
            .finish();
        Ok(())
    }
}
pub struct I8ValuesArgs<'a> {
    pub values: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i8>>>,
}
impl<'a> Default for I8ValuesArgs<'a> {
    #[inline]
    fn default() -> Self {
        I8ValuesArgs {
            values: None, // required field
        }
    }
}

pub struct I8ValuesBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> I8ValuesBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_values(&mut self, values: flatbuffers::WIPOffset<flatbuffers::Vector<'b, i8>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(I8Values::VT_VALUES, values);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> I8ValuesBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        I8ValuesBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<I8Values<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(o, I8Values::VT_VALUES, "values");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for I8Values<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("I8Values");
        ds.field("values", &self.values());
        ds.finish()
    }
}
pub enum I32ValuesOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct I32Values<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for I32Values<'a> {
    type Inner = I32Values<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> I32Values<'a> {
    pub const VT_VALUES: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        I32Values { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args I32ValuesArgs<'args>,
    ) -> flatbuffers::WIPOffset<I32Values<'bldr>> {
        let mut builder = I32ValuesBuilder::new(_fbb);
        if let Some(x) = args.values {
            builder.add_values(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn values(&self) -> flatbuffers::Vector<'a, i32> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i32>>>(
                    I32Values::VT_VALUES,
                    None,
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for I32Values<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i32>>>(
                "values",
                Self::VT_VALUES,
                true,
            )?
            .finish();
        Ok(())
    }
}
pub struct I32ValuesArgs<'a> {
    pub values: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i32>>>,
}
impl<'a> Default for I32ValuesArgs<'a> {
    #[inline]
    fn default() -> Self {
        I32ValuesArgs {
            values: None, // required field
        }
    }
}

pub struct I32ValuesBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> I32ValuesBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_values(&mut self, values: flatbuffers::WIPOffset<flatbuffers::Vector<'b, i32>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(I32Values::VT_VALUES, values);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> I32ValuesBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        I32ValuesBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<I32Values<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(o, I32Values::VT_VALUES, "values");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for I32Values<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("I32Values");
        ds.field("values", &self.values());
        ds.finish()
    }
}
pub enum I64ValuesOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct I64Values<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for I64Values<'a> {
    type Inner = I64Values<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> I64Values<'a> {
    pub const VT_VALUES: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        I64Values { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args I64ValuesArgs<'args>,
    ) -> flatbuffers::WIPOffset<I64Values<'bldr>> {
        let mut builder = I64ValuesBuilder::new(_fbb);
        if let Some(x) = args.values {
            builder.add_values(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn values(&self) -> flatbuffers::Vector<'a, i64> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, i64>>>(
                    I64Values::VT_VALUES,
                    None,
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for I64Values<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, i64>>>(
                "values",
                Self::VT_VALUES,
                true,
            )?
            .finish();
        Ok(())
    }
}
pub struct I64ValuesArgs<'a> {
    pub values: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, i64>>>,
}
impl<'a> Default for I64ValuesArgs<'a> {
    #[inline]
    fn default() -> Self {
        I64ValuesArgs {
            values: None, // required field
        }
    }
}

pub struct I64ValuesBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> I64ValuesBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_values(&mut self, values: flatbuffers::WIPOffset<flatbuffers::Vector<'b, i64>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(I64Values::VT_VALUES, values);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> I64ValuesBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        I64ValuesBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<I64Values<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(o, I64Values::VT_VALUES, "values");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for I64Values<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("I64Values");
        ds.field("values", &self.values());
        ds.finish()
    }
}
pub enum F32ValuesOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct F32Values<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for F32Values<'a> {
    type Inner = F32Values<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> F32Values<'a> {
    pub const VT_VALUES: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        F32Values { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args F32ValuesArgs<'args>,
    ) -> flatbuffers::WIPOffset<F32Values<'bldr>> {
        let mut builder = F32ValuesBuilder::new(_fbb);
        if let Some(x) = args.values {
            builder.add_values(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn values(&self) -> flatbuffers::Vector<'a, f32> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f32>>>(
                    F32Values::VT_VALUES,
                    None,
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for F32Values<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f32>>>(
                "values",
                Self::VT_VALUES,
                true,
            )?
            .finish();
        Ok(())
    }
}
pub struct F32ValuesArgs<'a> {
    pub values: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f32>>>,
}
impl<'a> Default for F32ValuesArgs<'a> {
    #[inline]
    fn default() -> Self {
        F32ValuesArgs {
            values: None, // required field
        }
    }
}

pub struct F32ValuesBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> F32ValuesBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_values(&mut self, values: flatbuffers::WIPOffset<flatbuffers::Vector<'b, f32>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(F32Values::VT_VALUES, values);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> F32ValuesBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        F32ValuesBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<F32Values<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(o, F32Values::VT_VALUES, "values");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for F32Values<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("F32Values");
        ds.field("values", &self.values());
        ds.finish()
    }
}
pub enum F64ValuesOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct F64Values<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for F64Values<'a> {
    type Inner = F64Values<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> F64Values<'a> {
    pub const VT_VALUES: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        F64Values { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args F64ValuesArgs<'args>,
    ) -> flatbuffers::WIPOffset<F64Values<'bldr>> {
        let mut builder = F64ValuesBuilder::new(_fbb);
        if let Some(x) = args.values {
            builder.add_values(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn values(&self) -> flatbuffers::Vector<'a, f64> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, f64>>>(
                    F64Values::VT_VALUES,
                    None,
                )
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for F64Values<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, f64>>>(
                "values",
                Self::VT_VALUES,
                true,
            )?
            .finish();
        Ok(())
    }
}
pub struct F64ValuesArgs<'a> {
    pub values: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, f64>>>,
}
impl<'a> Default for F64ValuesArgs<'a> {
    #[inline]
    fn default() -> Self {
        F64ValuesArgs {
            values: None, // required field
        }
    }
}

pub struct F64ValuesBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> F64ValuesBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_values(&mut self, values: flatbuffers::WIPOffset<flatbuffers::Vector<'b, f64>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(F64Values::VT_VALUES, values);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> F64ValuesBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        F64ValuesBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<F64Values<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(o, F64Values::VT_VALUES, "values");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for F64Values<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("F64Values");
        ds.field("values", &self.values());
        ds.finish()
    }
}
pub enum StringValuesOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct StringValues<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for StringValues<'a> {
    type Inner = StringValues<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> StringValues<'a> {
    pub const VT_VALUES: flatbuffers::VOffsetT = 4;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        StringValues { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args StringValuesArgs<'args>,
    ) -> flatbuffers::WIPOffset<StringValues<'bldr>> {
        let mut builder = StringValuesBuilder::new(_fbb);
        if let Some(x) = args.values {
            builder.add_values(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn values(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
                >>(StringValues::VT_VALUES, None)
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for StringValues<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("values", Self::VT_VALUES, true)?
            .finish();
        Ok(())
    }
}
pub struct StringValuesArgs<'a> {
    pub values: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
}
impl<'a> Default for StringValuesArgs<'a> {
    #[inline]
    fn default() -> Self {
        StringValuesArgs {
            values: None, // required field
        }
    }
}

pub struct StringValuesBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> StringValuesBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_values(
        &mut self,
        values: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(StringValues::VT_VALUES, values);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> StringValuesBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        StringValuesBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<StringValues<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(o, StringValues::VT_VALUES, "values");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for StringValues<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("StringValues");
        ds.field("values", &self.values());
        ds.finish()
    }
}
pub enum ListOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct List<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for List<'a> {
    type Inner = List<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> List<'a> {
    pub const VT_VALUES_TYPE: flatbuffers::VOffsetT = 4;
    pub const VT_VALUES: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        List { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args ListArgs,
    ) -> flatbuffers::WIPOffset<List<'bldr>> {
        let mut builder = ListBuilder::new(_fbb);
        if let Some(x) = args.values {
            builder.add_values(x);
        }
        builder.add_values_type(args.values_type);
        builder.finish()
    }

    #[inline]
    pub fn values_type(&self) -> ListValues {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<ListValues>(List::VT_VALUES_TYPE, Some(ListValues::NONE))
                .unwrap()
        }
    }
    #[inline]
    pub fn values(&self) -> flatbuffers::Table<'a> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(List::VT_VALUES, None)
                .unwrap()
        }
    }
    #[inline]
    #[allow(non_snake_case)]
    pub fn values_as_u8_values(&self) -> Option<U8Values<'a>> {
        if self.values_type() == ListValues::U8Values {
            let u = self.values();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid union in this slot
            Some(unsafe { U8Values::init_from_table(u) })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn values_as_u32_values(&self) -> Option<U32Values<'a>> {
        if self.values_type() == ListValues::U32Values {
            let u = self.values();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid union in this slot
            Some(unsafe { U32Values::init_from_table(u) })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn values_as_u64_values(&self) -> Option<U64Values<'a>> {
        if self.values_type() == ListValues::U64Values {
            let u = self.values();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid union in this slot
            Some(unsafe { U64Values::init_from_table(u) })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn values_as_i8_values(&self) -> Option<I8Values<'a>> {
        if self.values_type() == ListValues::I8Values {
            let u = self.values();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid union in this slot
            Some(unsafe { I8Values::init_from_table(u) })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn values_as_i32_values(&self) -> Option<I32Values<'a>> {
        if self.values_type() == ListValues::I32Values {
            let u = self.values();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid union in this slot
            Some(unsafe { I32Values::init_from_table(u) })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn values_as_i64_values(&self) -> Option<I64Values<'a>> {
        if self.values_type() == ListValues::I64Values {
            let u = self.values();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid union in this slot
            Some(unsafe { I64Values::init_from_table(u) })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn values_as_f32_values(&self) -> Option<F32Values<'a>> {
        if self.values_type() == ListValues::F32Values {
            let u = self.values();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid union in this slot
            Some(unsafe { F32Values::init_from_table(u) })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn values_as_f64_values(&self) -> Option<F64Values<'a>> {
        if self.values_type() == ListValues::F64Values {
            let u = self.values();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid union in this slot
            Some(unsafe { F64Values::init_from_table(u) })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn values_as_string_values(&self) -> Option<StringValues<'a>> {
        if self.values_type() == ListValues::StringValues {
            let u = self.values();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid union in this slot
            Some(unsafe { StringValues::init_from_table(u) })
        } else {
            None
        }
    }
}

impl flatbuffers::Verifiable for List<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_union::<ListValues, _>(
                "values_type",
                Self::VT_VALUES_TYPE,
                "values",
                Self::VT_VALUES,
                true,
                |key, v, pos| match key {
                    ListValues::U8Values => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<U8Values>>(
                            "ListValues::U8Values",
                            pos,
                        ),
                    ListValues::U32Values => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<U32Values>>(
                            "ListValues::U32Values",
                            pos,
                        ),
                    ListValues::U64Values => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<U64Values>>(
                            "ListValues::U64Values",
                            pos,
                        ),
                    ListValues::I8Values => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<I8Values>>(
                            "ListValues::I8Values",
                            pos,
                        ),
                    ListValues::I32Values => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<I32Values>>(
                            "ListValues::I32Values",
                            pos,
                        ),
                    ListValues::I64Values => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<I64Values>>(
                            "ListValues::I64Values",
                            pos,
                        ),
                    ListValues::F32Values => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<F32Values>>(
                            "ListValues::F32Values",
                            pos,
                        ),
                    ListValues::F64Values => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<F64Values>>(
                            "ListValues::F64Values",
                            pos,
                        ),
                    ListValues::StringValues => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<StringValues>>(
                            "ListValues::StringValues",
                            pos,
                        ),
                    _ => Ok(()),
                },
            )?
            .finish();
        Ok(())
    }
}
pub struct ListArgs {
    pub values_type: ListValues,
    pub values: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for ListArgs {
    #[inline]
    fn default() -> Self {
        ListArgs {
            values_type: ListValues::NONE,
            values: None, // required field
        }
    }
}

pub struct ListBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ListBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_values_type(&mut self, values_type: ListValues) {
        self.fbb_
            .push_slot::<ListValues>(List::VT_VALUES_TYPE, values_type, ListValues::NONE);
    }
    #[inline]
    pub fn add_values(&mut self, values: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(List::VT_VALUES, values);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ListBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        ListBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<List<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(o, List::VT_VALUES, "values");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for List<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("List");
        ds.field("values_type", &self.values_type());
        match self.values_type() {
            ListValues::U8Values => {
                if let Some(x) = self.values_as_u8_values() {
                    ds.field("values", &x)
                } else {
                    ds.field(
                        "values",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            ListValues::U32Values => {
                if let Some(x) = self.values_as_u32_values() {
                    ds.field("values", &x)
                } else {
                    ds.field(
                        "values",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            ListValues::U64Values => {
                if let Some(x) = self.values_as_u64_values() {
                    ds.field("values", &x)
                } else {
                    ds.field(
                        "values",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            ListValues::I8Values => {
                if let Some(x) = self.values_as_i8_values() {
                    ds.field("values", &x)
                } else {
                    ds.field(
                        "values",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            ListValues::I32Values => {
                if let Some(x) = self.values_as_i32_values() {
                    ds.field("values", &x)
                } else {
                    ds.field(
                        "values",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            ListValues::I64Values => {
                if let Some(x) = self.values_as_i64_values() {
                    ds.field("values", &x)
                } else {
                    ds.field(
                        "values",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            ListValues::F32Values => {
                if let Some(x) = self.values_as_f32_values() {
                    ds.field("values", &x)
                } else {
                    ds.field(
                        "values",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            ListValues::F64Values => {
                if let Some(x) = self.values_as_f64_values() {
                    ds.field("values", &x)
                } else {
                    ds.field(
                        "values",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            ListValues::StringValues => {
                if let Some(x) = self.values_as_string_values() {
                    ds.field("values", &x)
                } else {
                    ds.field(
                        "values",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            _ => {
                let x: Option<()> = None;
                ds.field("values", &x)
            }
        };
        ds.finish()
    }
}
pub enum StructOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Struct<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Struct<'a> {
    type Inner = Struct<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> Struct<'a> {
    pub const VT_FIELDS: flatbuffers::VOffsetT = 4;
    pub const VT_VALUES: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Struct { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args StructArgs<'args>,
    ) -> flatbuffers::WIPOffset<Struct<'bldr>> {
        let mut builder = StructBuilder::new(_fbb);
        if let Some(x) = args.values {
            builder.add_values(x);
        }
        if let Some(x) = args.fields {
            builder.add_fields(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn fields(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
                >>(Struct::VT_FIELDS, None)
                .unwrap()
        }
    }
    #[inline]
    pub fn values(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Value<'a>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Value>>,
                >>(Struct::VT_VALUES, None)
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for Struct<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("fields", Self::VT_FIELDS, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Value>>,
            >>("values", Self::VT_VALUES, true)?
            .finish();
        Ok(())
    }
}
pub struct StructArgs<'a> {
    pub fields: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub values: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Value<'a>>>>,
    >,
}
impl<'a> Default for StructArgs<'a> {
    #[inline]
    fn default() -> Self {
        StructArgs {
            fields: None, // required field
            values: None, // required field
        }
    }
}

pub struct StructBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> StructBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_fields(
        &mut self,
        fields: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Struct::VT_FIELDS, fields);
    }
    #[inline]
    pub fn add_values(
        &mut self,
        values: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Value<'b>>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Struct::VT_VALUES, values);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> StructBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        StructBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<Struct<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(o, Struct::VT_FIELDS, "fields");
        self.fbb_.required(o, Struct::VT_VALUES, "values");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for Struct<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("Struct");
        ds.field("fields", &self.fields());
        ds.field("values", &self.values());
        ds.finish()
    }
}
pub enum SparseVectorOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SparseVector<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SparseVector<'a> {
    type Inner = SparseVector<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> SparseVector<'a> {
    pub const VT_INDICES: flatbuffers::VOffsetT = 4;
    pub const VT_VALUES_TYPE: flatbuffers::VOffsetT = 6;
    pub const VT_VALUES: flatbuffers::VOffsetT = 8;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        SparseVector { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args SparseVectorArgs<'args>,
    ) -> flatbuffers::WIPOffset<SparseVector<'bldr>> {
        let mut builder = SparseVectorBuilder::new(_fbb);
        if let Some(x) = args.values {
            builder.add_values(x);
        }
        if let Some(x) = args.indices {
            builder.add_indices(x);
        }
        builder.add_values_type(args.values_type);
        builder.finish()
    }

    #[inline]
    pub fn indices(&self) -> flatbuffers::Vector<'a, u32> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u32>>>(
                    SparseVector::VT_INDICES,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn values_type(&self) -> SparseVectorValues {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<SparseVectorValues>(
                    SparseVector::VT_VALUES_TYPE,
                    Some(SparseVectorValues::NONE),
                )
                .unwrap()
        }
    }
    #[inline]
    pub fn values(&self) -> flatbuffers::Table<'a> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                    SparseVector::VT_VALUES,
                    None,
                )
                .unwrap()
        }
    }
    #[inline]
    #[allow(non_snake_case)]
    pub fn values_as_u8_values(&self) -> Option<U8Values<'a>> {
        if self.values_type() == SparseVectorValues::U8Values {
            let u = self.values();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid union in this slot
            Some(unsafe { U8Values::init_from_table(u) })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn values_as_f32_values(&self) -> Option<F32Values<'a>> {
        if self.values_type() == SparseVectorValues::F32Values {
            let u = self.values();
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid union in this slot
            Some(unsafe { F32Values::init_from_table(u) })
        } else {
            None
        }
    }
}

impl flatbuffers::Verifiable for SparseVector<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u32>>>(
                "indices",
                Self::VT_INDICES,
                true,
            )?
            .visit_union::<SparseVectorValues, _>(
                "values_type",
                Self::VT_VALUES_TYPE,
                "values",
                Self::VT_VALUES,
                true,
                |key, v, pos| match key {
                    SparseVectorValues::U8Values => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<U8Values>>(
                            "SparseVectorValues::U8Values",
                            pos,
                        ),
                    SparseVectorValues::F32Values => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<F32Values>>(
                            "SparseVectorValues::F32Values",
                            pos,
                        ),
                    _ => Ok(()),
                },
            )?
            .finish();
        Ok(())
    }
}
pub struct SparseVectorArgs<'a> {
    pub indices: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u32>>>,
    pub values_type: SparseVectorValues,
    pub values: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for SparseVectorArgs<'a> {
    #[inline]
    fn default() -> Self {
        SparseVectorArgs {
            indices: None, // required field
            values_type: SparseVectorValues::NONE,
            values: None, // required field
        }
    }
}

pub struct SparseVectorBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SparseVectorBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_indices(&mut self, indices: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u32>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(SparseVector::VT_INDICES, indices);
    }
    #[inline]
    pub fn add_values_type(&mut self, values_type: SparseVectorValues) {
        self.fbb_.push_slot::<SparseVectorValues>(
            SparseVector::VT_VALUES_TYPE,
            values_type,
            SparseVectorValues::NONE,
        );
    }
    #[inline]
    pub fn add_values(&mut self, values: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(SparseVector::VT_VALUES, values);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    ) -> SparseVectorBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        SparseVectorBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<SparseVector<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(o, SparseVector::VT_INDICES, "indices");
        self.fbb_.required(o, SparseVector::VT_VALUES, "values");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for SparseVector<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("SparseVector");
        ds.field("indices", &self.indices());
        ds.field("values_type", &self.values_type());
        match self.values_type() {
            SparseVectorValues::U8Values => {
                if let Some(x) = self.values_as_u8_values() {
                    ds.field("values", &x)
                } else {
                    ds.field(
                        "values",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            SparseVectorValues::F32Values => {
                if let Some(x) = self.values_as_f32_values() {
                    ds.field("values", &x)
                } else {
                    ds.field(
                        "values",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            _ => {
                let x: Option<()> = None;
                ds.field("values", &x)
            }
        };
        ds.finish()
    }
}
pub enum ValueOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Value<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Value<'a> {
    type Inner = Value<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> Value<'a> {
    pub const VT_VALUE_TYPE: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Value { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args ValueArgs,
    ) -> flatbuffers::WIPOffset<Value<'bldr>> {
        let mut builder = ValueBuilder::new(_fbb);
        if let Some(x) = args.value {
            builder.add_value(x);
        }
        builder.add_value_type(args.value_type);
        builder.finish()
    }

    #[inline]
    pub fn value_type(&self) -> ValueUnion {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<ValueUnion>(Value::VT_VALUE_TYPE, Some(ValueUnion::NONE))
                .unwrap()
        }
    }
    #[inline]
    pub fn value(&self) -> Option<flatbuffers::Table<'a>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Value::VT_VALUE, None)
        }
    }
    #[inline]
    #[allow(non_snake_case)]
    pub fn value_as_bool(&self) -> Option<Bool<'a>> {
        if self.value_type() == ValueUnion::Bool {
            self.value().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { Bool::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn value_as_u32(&self) -> Option<U32<'a>> {
        if self.value_type() == ValueUnion::U32 {
            self.value().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { U32::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn value_as_u64(&self) -> Option<U64<'a>> {
        if self.value_type() == ValueUnion::U64 {
            self.value().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { U64::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn value_as_i32(&self) -> Option<I32<'a>> {
        if self.value_type() == ValueUnion::I32 {
            self.value().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { I32::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn value_as_i64(&self) -> Option<I64<'a>> {
        if self.value_type() == ValueUnion::I64 {
            self.value().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { I64::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn value_as_f32(&self) -> Option<F32<'a>> {
        if self.value_type() == ValueUnion::F32 {
            self.value().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { F32::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn value_as_f64(&self) -> Option<F64<'a>> {
        if self.value_type() == ValueUnion::F64 {
            self.value().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { F64::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn value_as_string(&self) -> Option<String<'a>> {
        if self.value_type() == ValueUnion::String {
            self.value().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { String::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn value_as_bytes(&self) -> Option<Bytes<'a>> {
        if self.value_type() == ValueUnion::Bytes {
            self.value().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { Bytes::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn value_as_list(&self) -> Option<List<'a>> {
        if self.value_type() == ValueUnion::List {
            self.value().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { List::init_from_table(t) }
            })
        } else {
            None
        }
    }

    #[inline]
    #[allow(non_snake_case)]
    pub fn value_as_struct(&self) -> Option<Struct<'a>> {
        if self.value_type() == ValueUnion::Struct {
            self.value().map(|t| {
                // Safety:
                // Created from a valid Table for this object
                // Which contains a valid union in this slot
                unsafe { Struct::init_from_table(t) }
            })
        } else {
            None
        }
    }
}

impl flatbuffers::Verifiable for Value<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_union::<ValueUnion, _>(
                "value_type",
                Self::VT_VALUE_TYPE,
                "value",
                Self::VT_VALUE,
                false,
                |key, v, pos| match key {
                    ValueUnion::Bool => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<Bool>>(
                            "ValueUnion::Bool",
                            pos,
                        ),
                    ValueUnion::U32 => v.verify_union_variant::<flatbuffers::ForwardsUOffset<U32>>(
                        "ValueUnion::U32",
                        pos,
                    ),
                    ValueUnion::U64 => v.verify_union_variant::<flatbuffers::ForwardsUOffset<U64>>(
                        "ValueUnion::U64",
                        pos,
                    ),
                    ValueUnion::I32 => v.verify_union_variant::<flatbuffers::ForwardsUOffset<I32>>(
                        "ValueUnion::I32",
                        pos,
                    ),
                    ValueUnion::I64 => v.verify_union_variant::<flatbuffers::ForwardsUOffset<I64>>(
                        "ValueUnion::I64",
                        pos,
                    ),
                    ValueUnion::F32 => v.verify_union_variant::<flatbuffers::ForwardsUOffset<F32>>(
                        "ValueUnion::F32",
                        pos,
                    ),
                    ValueUnion::F64 => v.verify_union_variant::<flatbuffers::ForwardsUOffset<F64>>(
                        "ValueUnion::F64",
                        pos,
                    ),
                    ValueUnion::String => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<String>>(
                            "ValueUnion::String",
                            pos,
                        ),
                    ValueUnion::Bytes => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<Bytes>>(
                            "ValueUnion::Bytes",
                            pos,
                        ),
                    ValueUnion::List => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<List>>(
                            "ValueUnion::List",
                            pos,
                        ),
                    ValueUnion::Struct => v
                        .verify_union_variant::<flatbuffers::ForwardsUOffset<Struct>>(
                            "ValueUnion::Struct",
                            pos,
                        ),
                    _ => Ok(()),
                },
            )?
            .finish();
        Ok(())
    }
}
pub struct ValueArgs {
    pub value_type: ValueUnion,
    pub value: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for ValueArgs {
    #[inline]
    fn default() -> Self {
        ValueArgs {
            value_type: ValueUnion::NONE,
            value: None,
        }
    }
}

pub struct ValueBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ValueBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_value_type(&mut self, value_type: ValueUnion) {
        self.fbb_
            .push_slot::<ValueUnion>(Value::VT_VALUE_TYPE, value_type, ValueUnion::NONE);
    }
    #[inline]
    pub fn add_value(&mut self, value: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Value::VT_VALUE, value);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ValueBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        ValueBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<Value<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for Value<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("Value");
        ds.field("value_type", &self.value_type());
        match self.value_type() {
            ValueUnion::Bool => {
                if let Some(x) = self.value_as_bool() {
                    ds.field("value", &x)
                } else {
                    ds.field(
                        "value",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            ValueUnion::U32 => {
                if let Some(x) = self.value_as_u32() {
                    ds.field("value", &x)
                } else {
                    ds.field(
                        "value",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            ValueUnion::U64 => {
                if let Some(x) = self.value_as_u64() {
                    ds.field("value", &x)
                } else {
                    ds.field(
                        "value",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            ValueUnion::I32 => {
                if let Some(x) = self.value_as_i32() {
                    ds.field("value", &x)
                } else {
                    ds.field(
                        "value",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            ValueUnion::I64 => {
                if let Some(x) = self.value_as_i64() {
                    ds.field("value", &x)
                } else {
                    ds.field(
                        "value",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            ValueUnion::F32 => {
                if let Some(x) = self.value_as_f32() {
                    ds.field("value", &x)
                } else {
                    ds.field(
                        "value",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            ValueUnion::F64 => {
                if let Some(x) = self.value_as_f64() {
                    ds.field("value", &x)
                } else {
                    ds.field(
                        "value",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            ValueUnion::String => {
                if let Some(x) = self.value_as_string() {
                    ds.field("value", &x)
                } else {
                    ds.field(
                        "value",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            ValueUnion::Bytes => {
                if let Some(x) = self.value_as_bytes() {
                    ds.field("value", &x)
                } else {
                    ds.field(
                        "value",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            ValueUnion::List => {
                if let Some(x) = self.value_as_list() {
                    ds.field("value", &x)
                } else {
                    ds.field(
                        "value",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            ValueUnion::Struct => {
                if let Some(x) = self.value_as_struct() {
                    ds.field("value", &x)
                } else {
                    ds.field(
                        "value",
                        &"InvalidFlatbuffer: Union discriminant does not match value.",
                    )
                }
            }
            _ => {
                let x: Option<()> = None;
                ds.field("value", &x)
            }
        };
        ds.finish()
    }
}
pub enum DocumentOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Document<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Document<'a> {
    type Inner = Document<'a>;
    #[inline]
    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table::new(buf, loc),
        }
    }
}

impl<'a> Document<'a> {
    pub const VT_FIELDS: flatbuffers::VOffsetT = 4;
    pub const VT_VALUES: flatbuffers::VOffsetT = 6;

    #[inline]
    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Document { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
        args: &'args DocumentArgs<'args>,
    ) -> flatbuffers::WIPOffset<Document<'bldr>> {
        let mut builder = DocumentBuilder::new(_fbb);
        if let Some(x) = args.values {
            builder.add_values(x);
        }
        if let Some(x) = args.fields {
            builder.add_fields(x);
        }
        builder.finish()
    }

    #[inline]
    pub fn fields(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>,
                >>(Document::VT_FIELDS, None)
                .unwrap()
        }
    }
    #[inline]
    pub fn values(&self) -> flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Value<'a>>> {
        // Safety:
        // Created from valid Table for this object
        // which contains a valid value in this slot
        unsafe {
            self._tab
                .get::<flatbuffers::ForwardsUOffset<
                    flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Value>>,
                >>(Document::VT_VALUES, None)
                .unwrap()
        }
    }
}

impl flatbuffers::Verifiable for Document<'_> {
    #[inline]
    fn run_verifier(
        v: &mut flatbuffers::Verifier,
        pos: usize,
    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
        use self::flatbuffers::Verifiable;
        v.visit_table(pos)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<&'_ str>>,
            >>("fields", Self::VT_FIELDS, true)?
            .visit_field::<flatbuffers::ForwardsUOffset<
                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Value>>,
            >>("values", Self::VT_VALUES, true)?
            .finish();
        Ok(())
    }
}
pub struct DocumentArgs<'a> {
    pub fields: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<&'a str>>>,
    >,
    pub values: Option<
        flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Value<'a>>>>,
    >,
}
impl<'a> Default for DocumentArgs<'a> {
    #[inline]
    fn default() -> Self {
        DocumentArgs {
            fields: None, // required field
            values: None, // required field
        }
    }
}

pub struct DocumentBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> DocumentBuilder<'a, 'b, A> {
    #[inline]
    pub fn add_fields(
        &mut self,
        fields: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<&'b str>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Document::VT_FIELDS, fields);
    }
    #[inline]
    pub fn add_values(
        &mut self,
        values: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Value<'b>>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(Document::VT_VALUES, values);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> DocumentBuilder<'a, 'b, A> {
        let start = _fbb.start_table();
        DocumentBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<Document<'a>> {
        let o = self.fbb_.end_table(self.start_);
        self.fbb_.required(o, Document::VT_FIELDS, "fields");
        self.fbb_.required(o, Document::VT_VALUES, "values");
        flatbuffers::WIPOffset::new(o.value())
    }
}

impl core::fmt::Debug for Document<'_> {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        let mut ds = f.debug_struct("Document");
        ds.field("fields", &self.fields());
        ds.field("values", &self.values());
        ds.finish()
    }
}
#[inline]
/// Verifies that a buffer of bytes contains a `Value`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_value_unchecked`.
pub fn root_as_value(buf: &[u8]) -> Result<Value, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::root::<Value>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `Value` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_value_unchecked`.
pub fn size_prefixed_root_as_value(buf: &[u8]) -> Result<Value, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::size_prefixed_root::<Value>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `Value` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_value_unchecked`.
pub fn root_as_value_with_opts<'b, 'o>(
    opts: &'o flatbuffers::VerifierOptions,
    buf: &'b [u8],
) -> Result<Value<'b>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::root_with_opts::<Value<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `Value` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_value_unchecked`.
pub fn size_prefixed_root_as_value_with_opts<'b, 'o>(
    opts: &'o flatbuffers::VerifierOptions,
    buf: &'b [u8],
) -> Result<Value<'b>, flatbuffers::InvalidFlatbuffer> {
    flatbuffers::size_prefixed_root_with_opts::<Value<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a Value and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `Value`.
pub unsafe fn root_as_value_unchecked(buf: &[u8]) -> Value {
    flatbuffers::root_unchecked::<Value>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed Value and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `Value`.
pub unsafe fn size_prefixed_root_as_value_unchecked(buf: &[u8]) -> Value {
    flatbuffers::size_prefixed_root_unchecked::<Value>(buf)
}
#[inline]
pub fn finish_value_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<Value<'a>>,
) {
    fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_value_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<Value<'a>>,
) {
    fbb.finish_size_prefixed(root, None);
}
