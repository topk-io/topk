/* auto-generated by NAPI-RS */
/* eslint-disable */
/**
 * The main TopK client for interacting with the TopK service.
 *
 * This client provides access to collections and allows you to perform various operations
 * like creating collections, querying data, and managing documents.
 */
export declare class Client {
  /** Creates a new TopK client with the provided configuration. */
  constructor(config: ClientConfig)
  /**
   * Returns a client for managing collections.
   *
   * This method provides access to collection management operations like creating,
   * listing, and deleting collections.
   */
  collections(): CollectionsClient
  /** Returns a client for interacting with a specific collection. */
  collection(name: string): CollectionClient
}

/**
 * Client for interacting with a specific collection.
 *
 * This client provides methods to perform operations on a specific collection,
 * including querying, upserting, and deleting documents.
 * @internal
 * @hideconstructor
 */
export declare class CollectionClient {
  /** Retrieves documents by their IDs. */
  get(ids: Array<string>, fields?: Array<string> | undefined | null, options?: QueryOptions | undefined | null): Promise<Record<string, Record<string, any>>>
  /** Counts the number of documents in the collection. */
  count(options?: QueryOptions | undefined | null): Promise<number>
  /** Executes a query against the collection. */
  query(query: query.Query, options?: QueryOptions | undefined | null): Promise<Array<Record<string, any>>>
  /** Inserts or updates documents in the collection. */
  upsert(docs: Array<Record<string, any>>): Promise<string>
  /**
   * Updates documents in the collection.
   *
   * Existing documents will be merged with the provided fields.
   * Missing documents will be ignored.
   *
   * @returns The `LSN` at which the update was applied.
   * If no updates were applied, this will be empty.
   */
  update(docs: Array<Record<string, any>>, failOnMissing?: boolean | undefined | null): Promise<string>
  /**
   * Deletes documents from the collection by their IDs or using a filter expression.
   *
   * Example:
   * Delete documents by their IDs:
   * ```javascript
   * await client.collection("books").delete(["id_1", "id_2"])
   * ```
   *
   * Delete documents by a filter expression:
   * ```javascript
   * import { field } from "topk-js/query";
   *
   * await client.collection("books").delete(field("published_year").gt(1997))
   * ```
   */
  delete(expr: Array<string> | query.LogicalExpression): Promise<string>
}

/**
 * Client for managing collections.
 *
 * This client provides methods to create, list, get, and delete collections.
 * @internal
 * @hideconstructor
 */
export declare class CollectionsClient {
  /** Lists all collections in the current project. */
  list(): Promise<Array<Collection>>
  /** Creates a new collection with the specified schema. */
  create(name: string, schema: Record<string, schema.FieldSpec>): Promise<Collection>
  /** Retrieves information about a specific collection. */
  get(name: string): Promise<Collection>
  /**
   * Deletes a collection and all its data.
   *
   * <Warning>
   *   This operation is irreversible and will permanently delete all data in the collection.
   * </Warning>
   */
  delete(name: string): Promise<void>
}

/**
 * Configuration for exponential backoff between retry attempts.
 *
 * This struct controls how the delay between retry attempts increases over time.
 * All fields are optional and will use sensible defaults if not provided.
 */
export interface BackoffConfig {
  /** Base multiplier for exponential backoff (default: 2.0) */
  base?: number
  /** Initial delay before the first retry in milliseconds */
  initBackoff?: number
  /** Maximum delay between retries in milliseconds */
  maxBackoff?: number
}

/**
 * Configuration for the TopK client.
 *
 * This struct contains all the necessary configuration options to connect to the TopK API.
 * The `api_key` and `region` are required, while other options have sensible defaults.
 */
export interface ClientConfig {
  /** Your TopK API key for authentication */
  apiKey: string
  /** The region where your data is stored. For available regions see: https://docs.topk.io/regions. */
  region: string
  /** Custom host URL (optional, defaults to the standard TopK endpoint) */
  host?: string
  /** Whether to use HTTPS (optional, defaults to true) */
  https?: boolean
  /** Retry configuration for failed requests (optional) */
  retryConfig?: RetryConfig
}

/**
 * Represents a collection in the TopK service.
 *
 * A collection is a container for documents with a defined schema.
 * This struct contains metadata about the collection including its name,
 * organization, project, schema, and region.
 */
export interface Collection {
  /** Name of the collection */
  name: string
  /** Organization ID that owns the collection */
  orgId: string
  /** Project ID that contains the collection */
  projectId: string
  /** Schema definition for the collection fields */
  schema: Record<string, CollectionFieldSpec>
  /** Region where the collection is stored */
  region: string
}

/**
 * Represents a field specification within a collection schema.
 *
 * This struct defines the properties of a field in a collection,
 * including its data type, whether it's required, and any index configuration.
 */
export interface CollectionFieldSpec {
  /** Data type of the field */
  dataType: schema.DataType
  /** Whether the field is required (must be present in all documents) */
  required: boolean
  /** Index configuration for the field (optional) */
  index?: schema.FieldIndexUnion
}

/**
 * Consistency levels for query operations.
 *
 * - `Indexed`: Query returns results as soon as they are indexed (faster, eventual consistency)
 * - `Strong`: Query waits for all replicas to be consistent (slower, strong consistency)
 */
export type ConsistencyLevel = /** Indexed consistency - faster| eventual consistency */
'indexed'|
/** Strong consistency - slower| waits for all replicas */
'strong';

/**
 * Options for query operations.
 *
 * These options control the behavior of query operations, including consistency
 * guarantees and sequence number constraints.
 */
export interface QueryOptions {
  /** Last sequence number to query at (for consistency) */
  lsn?: string
  /** Consistency level for the query */
  consistency?: ConsistencyLevel
}

/**
 * Options for rerank stages.
 *
 * This struct contains configuration options for reranking results,
 * including the model, query, and fields to use.
 */
export interface RerankOptions {
  /** The reranking model to use */
  model?: string
  /** The query text for reranking */
  query?: string
  /** Fields to include in reranking */
  fields?: Array<string>
  /** Multiple of top-k to consider for reranking */
  topkMultiple?: number
}

/**
 * Configuration for retry behavior when requests fail.
 *
 * This struct allows you to customize how the client handles retries for failed requests.
 * All fields are optional and will use sensible defaults if not provided.
 */
export interface RetryConfig {
  /** Maximum number of retries to attempt before giving up */
  maxRetries?: number
  /** Total timeout for the entire retry chain in milliseconds */
  timeout?: number
  /** Backoff configuration for spacing out retry attempts */
  backoff?: BackoffConfig
}

export declare namespace data {
  /**
   * @internal
   * @hideconstructor
   * Instances of the `List` class are used to represent lists of values in TopK.
   * Usually created using data constructors such as [`f32_list()`](#f32list), [`i32_list()`](#i32list), etc.
   */
  export class List {
    /** @ignore */
    toString(): string
  }
  /**
   * @internal
   * @hideconstructor
   * Instances of the `SparseVector` class are used to represent sparse vectors in TopK.
   * Usually created using data constructors such as [`f32_sparse_vector()`](#f32sparsevector) or [`u8_sparse_vector()`](#u8sparsevector).
   */
  export class SparseVector {
    /** @ignore */
    toString(): string
  }
  /**
   * Creates a [List](https://docs.topk.io/sdk/topk-js/data#List) type containing a binary vector. This function is an alias for [binaryList()](https://docs.topk.io/sdk/topk-js/data#binarylist).
   *
   * Example:
   *
   * ```javascript
   * import { binaryVector } from "topk-js/data";
   *
   * binaryVector([0, 1, 1, 0])
   * ```
   */
  export function binaryVector(values: Array<number>): List
  /**
   * Creates a [List](https://docs.topk.io/sdk/topk-js/data#List) type containing bytes data.
   *
   * Example:
   *
   * ```javascript
   * import { bytes } from "topk-js/data";
   *
   * bytes([0, 1, 1, 0])
   * ```
   */
  export function bytes(buffer: Array<number> | Buffer): Buffer
  /**
   * Creates a [List](https://docs.topk.io/sdk/topk-js/data#List) type containing a list of 32-bit floating point numbers.
   *
   * Example:
   *
   * ```javascript
   * import { f32List } from "topk-js/data";
   *
   * f32List([0.12, 0.67, 0.82, 0.53])
   * ```
   */
  export function f32List(values: Array<number>): List
  /**
   * Creates a [SparseVector](https://docs.topk.io/sdk/topk-js/data#SparseVector) type containing a sparse vector of 32-bit floats. This function is an alias for [f32SparseList()](https://docs.topk.io/sdk/topk-js/data#f32sparselist).
   *
   * Example:
   *
   * ```javascript
   * import { f32SparseVector } from "topk-js/data";
   *
   * f32SparseVector({0: 0.12, 6: 0.67, 17: 0.82, 97: 0.53})
   * ```
   */
  export function f32SparseVector(vector: Record<number, number>): SparseVector
  /**
   * Creates a [List](https://docs.topk.io/sdk/topk-js/data#List) type containing a 32-bit float vector. This function is an alias for [f32List()](https://docs.topk.io/sdk/topk-js/data#f32list).
   *
   * Example:
   *
   * ```javascript
   * import { f32Vector } from "topk-js/data";
   *
   * f32Vector([0.12, 0.67, 0.82, 0.53])
   * ```
   */
  export function f32Vector(values: Array<number>): List
  /**
   * Creates a [List](https://docs.topk.io/sdk/topk-js/data#List) type containing a list of 64-bit floating point numbers.
   *
   * Example:
   *
   * ```javascript
   * import { f64List } from "topk-js/data";
   *
   * f64List([0.12, 0.67, 0.82, 0.53])
   * ```
   */
  export function f64List(values: Array<number>): List
  /**
   * Creates a [List](https://docs.topk.io/sdk/topk-js/data#List) type containing a list of 32-bit signed integers.
   *
   * Example:
   *
   * ```javascript
   * import { i32List } from "topk-js/data";
   *
   * i32List([0, 1, 2, 3])
   * ```
   */
  export function i32List(values: Array<number>): List
  /**
   * Creates a [List](https://docs.topk.io/sdk/topk-js/data#List) type containing a list of 64-bit signed integers.
   *
   * Example:
   *
   * ```javascript
   * import { i64List } from "topk-js/data";
   *
   * i64List([0, 1, 2, 3])
   * ```
   */
  export function i64List(values: Array<number>): List
  /**
   * Creates a [List](https://docs.topk.io/sdk/topk-js/data#List) type containing an 8-bit signed integer vector. This function is an alias for [i8List()](https://docs.topk.io/sdk/topk-js/data#i8list).
   *
   * Example:
   *
   * ```javascript
   * import { i8Vector } from "topk-js/data";
   *
   * i8Vector([-128, 127, -1, 0, 1])
   * ```
   */
  export function i8Vector(values: Array<number>): List
  /**
   * Creates a [List](https://docs.topk.io/sdk/topk-js/data#List) type containing a list of strings.
   *
   * Example:
   *
   * ```javascript
   * import { stringList } from "topk-js/data";
   *
   * stringList(["foo", "bar", "baz"])
   * ```
   */
  export function stringList(values: Array<string>): List
  /**
   * Creates a [List](https://docs.topk.io/sdk/topk-js/data#List) type containing a list of 32-bit unsigned integers.
   *
   * Example:
   *
   * ```javascript
   * import { u32List } from "topk-js/data";
   *
   * u32List([0, 1, 2, 3])
   * ```
   */
  export function u32List(values: Array<number>): List
  /**
   * Creates a [SparseVector](https://docs.topk.io/sdk/topk-js/data#SparseVector) type containing a sparse vector of 8-bit unsigned integers. This function is an alias for [u8SparseList()](https://docs.topk.io/sdk/topk-js/data#u8sparselist).
   *
   * Example:
   *
   * ```javascript
   * import { u8SparseVector } from "topk-js/data";
   *
   * u8SparseVector({0: 12, 6: 67, 17: 82, 97: 53})
   * ```
   */
  export function u8SparseVector(vector: Record<number, number>): SparseVector
  /**
   * Creates a [List](https://docs.topk.io/sdk/topk-js/data#List) type containing an 8-bit unsigned integer vector. This function is an alias for [u8List()](https://docs.topk.io/sdk/topk-js/data#u8list).
   *
   * Example:
   *
   * ```javascript
   * import { u8Vector } from "topk-js/data";
   *
   * u8Vector([0, 255, 1, 2, 3])
   * ```
   */
  export function u8Vector(values: Array<number>): List
}

export declare namespace query {
  /**
   * @internal
   * @hideconstructor
   */
  export class FunctionExpression {

  }
  /**
   * @internal
   * @hideconstructor
   */
  export class LogicalExpression {
    /** Returns a string representation of the logical expression. */
    toString(): string
    /** Checks if the expression evaluates to null. */
    isNull(): LogicalExpression
    /** Checks if the expression evaluates to a non-null value. */
    isNotNull(): LogicalExpression
    /** Computes the absolute value of the expression. */
    abs(): LogicalExpression
    /** Computes the natural logarithm of the expression. */
    ln(): LogicalExpression
    /** Computes the exponential of the expression. */
    exp(): LogicalExpression
    /** Computes the square root of the expression. */
    sqrt(): LogicalExpression
    /** Computes the square of the expression. */
    square(): LogicalExpression
    /** Checks if the expression equals another value. */
    eq(other: LogicalExpression | string | number | boolean | null | undefined): LogicalExpression
    /** Checks if the expression does not equal another value. */
    ne(other: LogicalExpression | string | number | boolean | null | undefined): LogicalExpression
    /** Checks if the expression is less than another value. */
    lt(other: LogicalExpression | number | string): LogicalExpression
    /** Checks if the expression is less than or equal to another value. */
    lte(other: LogicalExpression | number | string): LogicalExpression
    /** Checks if the expression is greater than another value. */
    gt(other: LogicalExpression | number | string): LogicalExpression
    /** Checks if the expression is greater than or equal to another value. */
    gte(other: LogicalExpression | number | string): LogicalExpression
    /** Adds another value to the expression. */
    add(other: LogicalExpression | number): LogicalExpression
    /** Subtracts another value from the expression. */
    sub(other: LogicalExpression | number): LogicalExpression
    /** Multiplies the expression by another value. */
    mul(other: LogicalExpression | number): LogicalExpression
    /** Divides the expression by another value. */
    div(other: LogicalExpression | number): LogicalExpression
    /** Computes the minimum of the expression and another value. */
    min(other: LogicalExpression | number | string): LogicalExpression
    /** Computes the maximum of the expression and another value. */
    max(other: LogicalExpression | number | string): LogicalExpression
    /** Computes the logical AND of the expression and another expression. */
    and(other: LogicalExpression | boolean): LogicalExpression
    /** Computes the logical OR of the expression and another expression. */
    or(other: LogicalExpression | boolean): LogicalExpression
    /** Checks if the expression starts with another value. */
    startsWith(other: LogicalExpression | string): LogicalExpression
    /** Checks if the expression contains another value. */
    contains(other: LogicalExpression | string | number): LogicalExpression
    /** Checks if the expression is in another value. */
    in(other: LogicalExpression | string | Array<string> | Array<number> | data.List): LogicalExpression
    /** Checks if the expression matches all terms against the field with keyword index. */
    matchAll(other: LogicalExpression | string | string[]): LogicalExpression
    /** Checks if the expression matches any term against the field with keyword index. */
    matchAny(other: LogicalExpression | string | string[]): LogicalExpression
    /** Coalesces nulls in the expression with another value. */
    coalesce(other: LogicalExpression | number): LogicalExpression
    /** Chooses between two values based on the expression. */
    choose(x: LogicalExpression | string | number | boolean | null | undefined, y: LogicalExpression | string | number | boolean | null | undefined): LogicalExpression
    /**
     * Multiplies the scoring expression by the provided `boost` value if the `condition` is true.
     * Otherwise, the scoring expression is unchanged (multiplied by 1).
     */
    boost(condition: LogicalExpression | boolean, boost: LogicalExpression | number): LogicalExpression
  }
  /**
   * @internal
   * @hideconstructor
   * A query object that represents a sequence of query stages.
   *
   * Queries are built by chaining together different stages like select, filter, topk, etc.
   * Each stage performs a specific operation on the data.
   */
  export class Query {
    /** Adds a filter stage to the query. */
    filter(expr: LogicalExpression | TextExpression): Query
    /** Adds a select stage to the query. */
    select(exprs: Record<string, LogicalExpression | FunctionExpression>): Query
    /** Adds a top-k stage to the query. */
    topk(expr: LogicalExpression, k: number, asc?: boolean | undefined | null): Query
    /** Adds a limit stage to the query. */
    limit(k: number): Query
    /** Adds a sort stage to the query. */
    sort(expr: LogicalExpression, asc?: boolean | undefined | null): Query
    /** Adds a count stage to the query. */
    count(): Query
    /** Adds a rerank stage to the query. */
    rerank(options?: RerankOptions | undefined | null): Query
  }
  export class TextExpression {
    /** Computes the logical AND of the expression and another text expression. */
    and(other: TextExpression): TextExpression
    /** Computes the logical OR of the expression and another text expression. */
    or(other: TextExpression): TextExpression
  }
  /** Creates an absolute value expression. */
  export function abs(expr: LogicalExpression): LogicalExpression
  /** Evaluates to true if each `expr` is true. */
  export function all(exprs: Array<LogicalExpression>): LogicalExpression
  /** Evaluates to true if at least one `expr` is true. */
  export function any(exprs: Array<LogicalExpression>): LogicalExpression
  /** @ignore */
  export type BinaryOperator =  'and'|
  'or'|
  'eq'|
  'neq'|
  'lt'|
  'lte'|
  'gt'|
  'gte'|
  'startsWith'|
  'contains'|
  'in'|
  'add'|
  'sub'|
  'mul'|
  'div'|
  'matchAll'|
  'matchAny'|
  'coalesce'|
  'min'|
  'max';
  /** Creates a field reference expression. */
  export function field(name: string): LogicalExpression
  /** Creates a new query with a filter stage. */
  export function filter(expr: LogicalExpression | TextExpression): Query
  /** Creates a literal value expression. */
  export function literal(value: number | string | string[] | number[] | boolean | data.List): LogicalExpression
  /** Creates a text match expression. */
  export function match(token: string, options?: MatchOptions | undefined | null): TextExpression
  /**
   * Options for text matching.
   *
   * This struct contains configuration options for text matching operations,
   * including field specification, weight, and matching behavior.
   */
  export interface MatchOptions {
    /** Field to match against */
    field?: string
    /** Weight for the match */
    weight?: number
    /** Whether to match all terms */
    all?: boolean
  }
  /** Creates a MAX expression that returns the larger of two values. */
  export function max(left: LogicalExpression | number | string, right: LogicalExpression | number | string): LogicalExpression
  /** Creates a MIN expression that returns the smaller of two values. */
  export function min(left: LogicalExpression | number | string, right: LogicalExpression | number | string): LogicalExpression
  /** Creates a logical NOT expression. */
  export function not(expr: LogicalExpression): LogicalExpression
  /** Creates a new query with a select stage. */
  export function select(exprs: Record<string, LogicalExpression | FunctionExpression>): Query
  export interface Term {
    /** The token to match. */
    token: string
    /** The field to match against. */
    field?: string
    /** The weight of the term. */
    weight: number
  }
  /** @ignore */
  export type TernaryOperator =  'choose';
  /** @ignore */
  export type UnaryOperator =  'not'|
  'isNull'|
  'isNotNull'|
  'abs'|
  'ln'|
  'exp'|
  'sqrt'|
  'square';
}

export declare namespace query_fn {
  /** Computes the BM25 score for a keyword search. */
  export function bm25Score(): query.FunctionExpression
  /** Computes the semantic similarity between a field and a query string. */
  export function semanticSimilarity(field: string, query: string): query.FunctionExpression
  /** Computes the vector distance between a field and a query vector. */
  export function vectorDistance(field: string, query: Array<number> | Record<number, number> | data.List | data.SparseVector, options?: VectorDistanceOptions | undefined | null): query.FunctionExpression
  export interface VectorDistanceOptions {
    skipRefine?: boolean
  }
}

export declare namespace schema {
  /**
   * @internal
   * @hideconstructor
   */
  export class FieldIndex {

  }
  /**
   * @internal
   * @hideconstructor
   */
  export class FieldSpec {
    /**
     * Marks the field as required. All fields are optional by default.
     *
     * Example:
     *
     * ```javascript
     * import { text } from "topk-js/schema";
     *
     * await client.collections().create("books", {
     *   title: text().required()
     * });
     * ```
     */
    required(): FieldSpec
    /**
     * Creates an index on a field.
     *
     * Example:
     *
     * ```javascript
     * import { text, keywordIndex } from "topk-js/schema";
     *
     * await client.collections().create("books", {
     *   title: text().index(keywordIndex())
     * });
     * ```
     */
    index(index: FieldIndex): FieldSpec
  }
  /**
   * Creates a [FieldSpec](https://docs.topk.io/sdk/topk-js/schema#FieldSpec) type for `binary_vector` values.
   *
   * Example:
   *
   * ```javascript
   * import { binaryVector } from "topk-js/schema";
   *
   * await client.collections().create("books", {
   *   title_embedding: binaryVector({ dimension: 128 })
   * });
   * ```
   */
  export function binaryVector(options: VectorOptions): FieldSpec
  /**
   * Creates a [FieldSpec](https://docs.topk.io/sdk/topk-js/schema#FieldSpec) type for `bool` values.
   *
   * Example:
   *
   * ```javascript
   * import { bool } from "topk-js/schema";
   *
   * await client.collections().create("books", {
   *   is_published: bool()
   * });
   * ```
   */
  export function bool(): FieldSpec
  /**
   * Creates a [FieldSpec](https://docs.topk.io/sdk/topk-js/schema#FieldSpec) type for `bytes` values.
   *
   * Example:
   *
   * ```javascript
   * import { bytes } from "topk-js/schema";
   *
   * await client.collections().create("books", {
   *   image: bytes()
   * });
   * ```
   */
  export function bytes(): FieldSpec
  /** @ignore */
  export type DataType =
    | { type: 'Text' }
    | { type: 'Integer' }
    | { type: 'Float' }
    | { type: 'Boolean' }
    | { type: 'F32Vector', dimension: number }
    | { type: 'U8Vector', dimension: number }
    | { type: 'I8Vector', dimension: number }
    | { type: 'BinaryVector', dimension: number }
    | { type: 'F32SparseVector' }
    | { type: 'U8SparseVector' }
    | { type: 'Bytes' }
    | { type: 'List', valueType: ListValueType }
  export type EmbeddingDataType =  'float32'|
  'uint8'|
  'binary';
  /**
   * Creates a [FieldSpec](https://docs.topk.io/sdk/topk-js/schema#FieldSpec) type for `f32_sparse_vector` values.
   *
   * Note: Sparse vectors use u32 dimension indices to support dictionaries of up to 2^32 - 1 terms.
   *
   * Example:
   *
   * ```javascript
   * import { f32SparseVector } from "topk-js/schema";
   *
   * await client.collections().create("books", {
   *   sparse_field: f32SparseVector()
   * });
   * ```
   */
  export function f32SparseVector(): FieldSpec
  /**
   * Creates a [FieldSpec](https://docs.topk.io/sdk/topk-js/schema#FieldSpec) type for `f32_vector` values.
   *
   * Example:
   *
   * ```javascript
   * import { f32Vector } from "topk-js/schema";
   *
   * await client.collections().create("books", {
   *   title_embedding: f32Vector({ dimension: 1536 })
   * });
   * ```
   */
  export function f32Vector(options: VectorOptions): FieldSpec
  /** @ignore */
  export type FieldIndexUnion =
    | { type: 'KeywordIndex', indexType: KeywordIndexType }
    | { type: 'VectorIndex', metric: VectorDistanceMetric }
    | { type: 'SemanticIndex', model?: string, embeddingType?: EmbeddingDataType }
  /**
   * Creates a [FieldSpec](https://docs.topk.io/sdk/topk-js/schema#FieldSpec) type for `float` values.
   *
   * Example:
   *
   * ```javascript
   * import { float } from "topk-js/schema";
   *
   * await client.collections().create("books", {
   *   price: float()
   * });
   * ```
   */
  export function float(): FieldSpec
  /**
   * Creates a [FieldSpec](https://docs.topk.io/sdk/topk-js/schema#FieldSpec) type for `i8_vector` values.
   *
   * Example:
   *
   * ```javascript
   * import { i8Vector } from "topk-js/schema";
   *
   * await client.collections().create("books", {
   *   title_embedding: i8Vector({ dimension: 1536 })
   * });
   * ```
   */
  export function i8Vector(options: VectorOptions): FieldSpec
  /**
   * Creates a [FieldSpec](https://docs.topk.io/sdk/topk-js/schema#FieldSpec) type for `int` values.
   *
   * Example:
   *
   * ```javascript
   * import { int } from "topk-js/schema";
   *
   * await client.collections().create("books", {
   *   published_year: int()
   * });
   * ```
   */
  export function int(): FieldSpec
  /**
   * Creates a [FieldIndex](https://docs.topk.io/sdk/topk-js/schema#FieldIndex) type for `keyword_index` values.
   *
   * Example:
   *
   * ```javascript
   * import { text, keywordIndex } from "topk-js/schema";
   *
   * await client.collections().create("books", {
   *   title: text().index(keywordIndex())
   * });
   * ```
   *
   * Adding a keyword index allows you to perform keyword search on this field.
   */
  export function keywordIndex(): FieldIndex
  export type KeywordIndexType =  'text';
  /**
   * Creates a [FieldSpec](https://docs.topk.io/sdk/topk-js/schema#FieldSpec) type for `list` values.
   *
   * Example:
   *
   * ```javascript
   * import { list } from "topk-js/schema";
   *
   * await client.collections().create("books", {
   *   tags: list({ valueType: "text" })
   * });
   * ```
   */
  export function list(options: ListOptions): FieldSpec
  /**
   * Options for list field specifications.
   *
   * This struct contains configuration options for list fields,
   * including the type of values the list can contain.
   */
  export interface ListOptions {
    /** The type of values the list can contain */
    valueType: ListValueType
  }
  export type ListValueType =  'text'|
  'integer'|
  'float';
  /**
   * Creates a [FieldIndex](https://docs.topk.io/sdk/topk-js/schema#FieldIndex) type for `semantic_index` values.
   *
   * Example:
   *
   * ```javascript
   * import { text, semanticIndex } from "topk-js/schema";
   *
   * await client.collections().create("books", {
   *   title: text().index(semanticIndex({ model: "cohere/embed-v4" }))
   * });
   * ```
   *
   * Parameters:
   * - model: Embedding model to use for semantic search. Currently supported:
   *   - `cohere/embed-english-v3`
   *   - `cohere/embed-multilingual-v3`
   *   - `cohere/embed-v4` (default)
   * - embeddingType: TopK supports the following embedding types for Cohere models:
   *   - `float32`
   *   - `uint8`
   *   - `binary`
   */
  export function semanticIndex(options?: SemanticIndexOptions | undefined | null): FieldIndex
  /**
   * Options for semantic index specifications.
   *
   * This struct contains configuration options for semantic indexes,
   * including the model and embedding type to use.
   */
  export interface SemanticIndexOptions {
    /** The embedding model to use */
    model?: string
    /** The type of embedding data */
    embeddingType?: EmbeddingDataType
  }
  /**
   * Creates a [FieldSpec](https://docs.topk.io/sdk/topk-js/schema#FieldSpec) type for `text` values.
   *
   * Example:
   *
   * ```javascript
   * import { text } from "topk-js/schema";
   *
   * await client.collections().create("books", {
   *   title: text()
   * });
   * ```
   */
  export function text(): FieldSpec
  /**
   * Creates a [FieldSpec](https://docs.topk.io/sdk/topk-js/schema#FieldSpec) type for `u8_sparse_vector` values.
   *
   * Note: Sparse vectors use u32 dimension indices to support dictionaries of up to 2^32 - 1 terms.
   *
   * Example:
   *
   * ```javascript
   * import { u8SparseVector } from "topk-js/schema";
   *
   * await client.collections().create("books", {
   *   sparse_field: u8SparseVector()
   * });
   * ```
   */
  export function u8SparseVector(): FieldSpec
  /**
   * Creates a [FieldSpec](https://docs.topk.io/sdk/topk-js/schema#FieldSpec) type for `u8_vector` values.
   *
   * Example:
   *
   * ```javascript
   * import { u8Vector } from "topk-js/schema";
   *
   * await client.collections().create("books", {
   *   title_embedding: u8Vector({ dimension: 1536 })
   * });
   * ```
   */
  export function u8Vector(options: VectorOptions): FieldSpec
  export type VectorDistanceMetric =  'cosine'|
  'euclidean'|
  'dot_product'|
  'hamming';
  /**
   * Creates a [FieldIndex](https://docs.topk.io/sdk/topk-js/schema#FieldIndex) type for `vector_index` values.
   *
   * Supported `metric`s:
   * - `euclidean` (not supported for sparse vectors)
   * - `cosine` (not supported for sparse vectors)
   * - `dot_product` (supported for dense and sparse vectors)
   * - `hamming` (only supported for binary_vector type)
   *
   * Example:
   *
   * ```javascript
   * import { f32Vector, vectorIndex } from "topk-js/schema";
   *
   * await client.collections().create("books", {
   *   title_embedding: f32Vector({ dimension: 1536 }).index(
   *     vectorIndex({ metric: "cosine" })
   *   )
   * });
   * ```
   */
  export function vectorIndex(options: VectorIndexOptions): FieldIndex
  /**
   * Options for vector index specifications.
   *
   * This struct contains configuration options for vector indexes,
   * including the distance metric to use.
   */
  export interface VectorIndexOptions {
    /** The distance metric to use for vector similarity */
    metric: VectorDistanceMetric
  }
  /**
   * Options for vector field specifications.
   *
   * This struct contains configuration options for vector fields,
   * including the required dimension parameter.
   */
  export interface VectorOptions {
    /** The dimension of the vector */
    dimension: number
  }
}
