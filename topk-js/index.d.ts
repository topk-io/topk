/* auto-generated by NAPI-RS */
/* eslint-disable */
export declare class Client {
  constructor(config: ClientConfig)
  collections(): CollectionsClient
  collection(name: string): CollectionClient
}

export declare class CollectionClient {
  get(ids: Array<string>, fields?: Array<string> | undefined | null, options?: QueryOptions | undefined | null): Promise<Record<string, Record<string, any>>>
  count(options?: QueryOptions | undefined | null): Promise<number>
  query(query: query.Query, options?: QueryOptions | undefined | null): Promise<Array<Record<string, any>>>
  upsert(docs: Array<Record<string, any>>): Promise<string>
  delete(ids: Array<string>): Promise<string>
}

export declare class CollectionsClient {
  list(): Promise<Array<Collection>>
  create(name: string, schema: Record<string, schema.FieldSpec>): Promise<Collection>
  get(name: string): Promise<Collection>
  delete(name: string): Promise<void>
}

export interface BackoffConfig {
  /** Base for the backoff */
  base?: number
  /** Initial backoff (milliseconds) */
  initBackoff?: number
  /** Maximum backoff (milliseconds) */
  maxBackoff?: number
}

export interface ClientConfig {
  apiKey: string
  region: string
  host?: string
  https?: boolean
  retryConfig?: RetryConfig
}

export interface Collection {
  /** Name of the collection */
  name: string
  /** Organization ID */
  orgId: string
  /** Project ID */
  projectId: string
  /** Schema of the collection */
  schema: Record<string, CollectionFieldSpec>
  /** Region of the collection */
  region: string
}

export interface CollectionFieldSpec {
  /** Data type of the field */
  dataType: schema.DataType
  /** Whether the field is required */
  required: boolean
  /** Index configuration for the field */
  index?: schema.FieldIndexUnion
}

export type ConsistencyLevel =  'indexed'|
'strong';

export interface CreateCollectionOptions {
  name: string
  schema: Record<string, schema.FieldSpec>
}

export interface MatchOptions {
  field?: string
  weight?: number
  all?: boolean
}

export interface QueryOptions {
  /** Last sequence number to query at */
  lsn?: string
  /** Consistency level */
  consistency?: ConsistencyLevel
}

export interface RerankOptions {
  model?: string
  query?: string
  fields?: Array<string>
  topkMultiple?: number
}

export interface RetryConfig {
  /** Maximum number of retries */
  maxRetries?: number
  /** Total timeout for the retry chain (milliseconds) */
  timeout?: number
  /** Backoff configuration */
  backoff?: BackoffConfig
}

export declare namespace data {
  export class List {
    toString(): string
  }
  export class SparseVector {
    toString(): string
  }
  export function binaryVector(values: Array<number>): List
  export function bytes(buffer: Array<number> | Buffer): any
  export function f32List(values: Array<number>): List
  export function f32SparseVector(vector: Record<number, number>): SparseVector
  export function f32Vector(values: Array<number>): List
  export function f64List(values: Array<number>): List
  export function i32List(values: Array<number>): List
  export function i64List(values: Array<number>): List
  export function stringList(values: Array<string>): List
  export function u32List(values: Array<number>): List
  export function u8SparseVector(vector: Record<number, number>): SparseVector
  export function u8Vector(values: Array<number>): List
}

export declare namespace query {
  export class FunctionExpression {

  }
  export class LogicalExpression {
    toString(): string
    isNull(): LogicalExpression
    isNotNull(): LogicalExpression
    abs(): LogicalExpression
    ln(): LogicalExpression
    exp(): LogicalExpression
    sqrt(): LogicalExpression
    square(): LogicalExpression
    eq(other: LogicalExpression | string | number | boolean | null | undefined): LogicalExpression
    ne(other: LogicalExpression | string | number | boolean | null | undefined): LogicalExpression
    lt(other: LogicalExpression | number): LogicalExpression
    lte(other: LogicalExpression | number): LogicalExpression
    gt(other: LogicalExpression | number): LogicalExpression
    gte(other: LogicalExpression | number): LogicalExpression
    add(other: LogicalExpression | number): LogicalExpression
    sub(other: LogicalExpression | number): LogicalExpression
    mul(other: LogicalExpression | number): LogicalExpression
    div(other: LogicalExpression | number): LogicalExpression
    min(other: LogicalExpression | number): LogicalExpression
    max(other: LogicalExpression | number): LogicalExpression
    and(other: LogicalExpression | boolean): LogicalExpression
    or(other: LogicalExpression | boolean): LogicalExpression
    startsWith(other: LogicalExpression | string): LogicalExpression
    contains(other: LogicalExpression | string): LogicalExpression
    matchAll(other: LogicalExpression | string | string[]): LogicalExpression
    matchAny(other: LogicalExpression | string | string[]): LogicalExpression
    coalesce(other: LogicalExpression | number): LogicalExpression
    choose(x: LogicalExpression | string | number | boolean | null | undefined, y: LogicalExpression | string | number | boolean | null | undefined): LogicalExpression
    /**
     * Multiplies the scoring expression by the provided `boost` value if the `condition` is true.
     * Otherwise, the scoring expression is unchanged (multiplied by 1).
     */
    boost(condition: LogicalExpression | boolean, boost: LogicalExpression | number): LogicalExpression
  }
  export class Query {
    filter(expr: LogicalExpression | TextExpression): Query
    select(exprs: Record<string, LogicalExpression | FunctionExpression>): Query
    topk(expr: LogicalExpression, k: number, asc?: boolean | undefined | null): Query
    count(): Query
    rerank(options?: RerankOptions | undefined | null): Query
  }
  export class TextExpression {
    and(other: TextExpression): TextExpression
    or(other: TextExpression): TextExpression
  }
  export function abs(expr: LogicalExpression): LogicalExpression
  export type BinaryOperator =  'and'|
  'or'|
  'eq'|
  'neq'|
  'lt'|
  'lte'|
  'gt'|
  'gte'|
  'startsWith'|
  'contains'|
  'add'|
  'sub'|
  'mul'|
  'div'|
  'matchAll'|
  'matchAny'|
  'coalesce'|
  'min'|
  'max';
  export function field(name: string): LogicalExpression
  export function filter(expr: LogicalExpression | TextExpression): Query
  export function literal(value: number | string | string[] | number[] | boolean | data.List): LogicalExpression
  export function match(token: string, options?: MatchOptions | undefined | null): TextExpression
  export function max(left: LogicalExpression | number, right: LogicalExpression | number): LogicalExpression
  export function min(left: LogicalExpression | number, right: LogicalExpression | number): LogicalExpression
  export function not(expr: LogicalExpression): LogicalExpression
  export function select(exprs: Record<string, LogicalExpression | FunctionExpression>): Query
  export interface Term {
    token: string
    field?: string
    weight: number
  }
  export type TernaryOperator =  'choose';
  export type UnaryOperator =  'not'|
  'isNull'|
  'isNotNull'|
  'abs'|
  'ln'|
  'exp'|
  'sqrt'|
  'square';
}

export declare namespace query_fn {
  export function bm25Score(): query.FunctionExpression
  export function semanticSimilarity(field: string, query: string): query.FunctionExpression
  export function vectorDistance(field: string, query: Array<number> | Record<number, number> | data.List | data.SparseVector, options?: VectorDistanceOptions | undefined | null): query.FunctionExpression
  export interface VectorDistanceOptions {
    skipRefine?: boolean
  }
}

export declare namespace schema {
  export class FieldIndex {

  }
  export class FieldSpec {
    required(): FieldSpec
    index(index: FieldIndex): FieldSpec
  }
  export function binaryVector(options: VectorOptions): FieldSpec
  export function bool(): FieldSpec
  export function bytes(): FieldSpec
  export type DataType =
    | { type: 'Text' }
    | { type: 'Integer' }
    | { type: 'Float' }
    | { type: 'Boolean' }
    | { type: 'F32Vector', dimension: number }
    | { type: 'U8Vector', dimension: number }
    | { type: 'BinaryVector', dimension: number }
    | { type: 'F32SparseVector' }
    | { type: 'U8SparseVector' }
    | { type: 'Bytes' }
    | { type: 'List', valueType: ListValueType }
  export type EmbeddingDataType =  'float32'|
  'uint8'|
  'binary';
  export function f32SparseVector(): FieldSpec
  export function f32Vector(options: VectorOptions): FieldSpec
  export type FieldIndexUnion =
    | { type: 'KeywordIndex', indexType: KeywordIndexType }
    | { type: 'VectorIndex', metric: VectorDistanceMetric }
    | { type: 'SemanticIndex', model?: string, embeddingType?: EmbeddingDataType }
  export function float(): FieldSpec
  export function int(): FieldSpec
  export function keywordIndex(): FieldIndex
  export type KeywordIndexType =  'text';
  export function list(options: ListOptions): FieldSpec
  export interface ListOptions {
    valueType: ListValueType
  }
  export type ListValueType =  'text'|
  'integer'|
  'float';
  export function semanticIndex(options?: SemanticIndexOptions | undefined | null): FieldIndex
  export interface SemanticIndexOptions {
    model?: string
    embeddingType?: EmbeddingDataType
  }
  export function text(): FieldSpec
  export function u8SparseVector(): FieldSpec
  export function u8Vector(options: VectorOptions): FieldSpec
  export type VectorDistanceMetric =  'cosine'|
  'euclidean'|
  'dot_product'|
  'hamming';
  export function vectorIndex(options: VectorIndexOptions): FieldIndex
  export interface VectorIndexOptions {
    metric: VectorDistanceMetric
  }
  export interface VectorOptions {
    dimension: number
  }
}
