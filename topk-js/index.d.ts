/* auto-generated by NAPI-RS */
/* eslint-disable */
export declare class Client {
  constructor(config: ClientConfig)
  collections(): CollectionsClient
  collection(name: string): CollectionClient
}

export declare class CollectionClient {
  get(ids: Array<string>, fields?: Array<string> | undefined | null, options?: QueryOptions | undefined | null): Promise<Record<string, Record<string, any>>>
  count(options?: QueryOptions | undefined | null): Promise<number>
  query(query: query.Query, options?: QueryOptions | undefined | null): Promise<Array<Record<string, any>>>
  upsert(docs: Array<Record<string, any>>): Promise<string>
  delete(ids: Array<string>): Promise<string>
}

export declare class CollectionsClient {
  list(): Promise<Array<Collection>>
  create(name: string, schema: Record<string, schema.FieldSpec>): Promise<Collection>
  get(name: string): Promise<Collection>
  delete(name: string): Promise<void>
}

export interface BackoffConfig {
  /** Base for the backoff */
  base?: number
  /** Initial backoff (milliseconds) */
  initBackoff?: number
  /** Maximum backoff (milliseconds) */
  maxBackoff?: number
}

export interface ClientConfig {
  apiKey: string
  region: string
  host?: string
  https?: boolean
  retryConfig?: RetryConfig
}

export interface Collection {
  name: string
  orgId: string
  projectId: string
  schema: Record<string, CollectionFieldSpec>
  region: string
}

export interface CollectionFieldSpec {
  dataType: schema.DataType
  required: boolean
  index?: schema.FieldIndexUnion
}

export type ConsistencyLevel =  'indexed'|
'strong';

export interface CreateCollectionOptions {
  name: string
  schema: Record<string, schema.FieldSpec>
}

export interface MatchOptions {
  field?: string
  weight?: number
  all?: boolean
}

export interface QueryOptions {
  lsn?: string
  consistency?: ConsistencyLevel
}

export interface RerankOptions {
  model?: string
  query?: string
  fields?: Array<string>
  topkMultiple?: number
}

export interface RetryConfig {
  /** Maximum number of retries */
  maxRetries?: number
  /** Total timeout for the retry chain (milliseconds) */
  timeout?: number
  /** Backoff configuration */
  backoff?: BackoffConfig
}

export declare namespace data {
  export class SparseVector {

  }
  export class Vector {
    get values(): VectorUnion
  }
  export function binaryVector(values: Array<number>): Vector
  export function bytes(values: Array<number>): any
  export function f32Vector(values: Array<number>): Vector
  export type SparseVectorUnion =
    | { type: 'Float', vector: Record<number, number> }
    | { type: 'Byte', vector: Record<number, number> }
  export function u8Vector(values: Array<number>): Vector
  export type VectorUnion =
    | { type: 'Float', values: Array<number> }
    | { type: 'Byte', values: Array<number> }
    | { type: 'Binary', values: Array<number> }
}

export declare namespace query {
  export class LogicalExpression {
    static create(expr: LogicalExpressionUnion): LogicalExpression
    get expr(): LogicalExpressionUnion
    isNull(): LogicalExpression
    isNotNull(): LogicalExpression
    eq(other: LogicalExpression | string | number | boolean | null | undefined): LogicalExpression
    ne(other: LogicalExpression | string | number | boolean | null | undefined): LogicalExpression
    lt(other: LogicalExpression | number): LogicalExpression
    lte(other: LogicalExpression | number): LogicalExpression
    gt(other: LogicalExpression | number): LogicalExpression
    gte(other: LogicalExpression | number): LogicalExpression
    add(other: LogicalExpression | number): LogicalExpression
    sub(other: LogicalExpression | number): LogicalExpression
    mul(other: LogicalExpression | number): LogicalExpression
    div(other: LogicalExpression | number): LogicalExpression
    and(other: LogicalExpression | boolean): LogicalExpression
    or(other: LogicalExpression | boolean): LogicalExpression
    startsWith(other: LogicalExpression | string): LogicalExpression
    contains(other: LogicalExpression | string): LogicalExpression
  }
  export class Query {
    constructor()
    static select(exprs: Record<string, LogicalExpression | FunctionExpression>): Query
    filter(expr: LogicalExpression | TextExpression): Query
    topk(expr: LogicalExpression, k: number, asc?: boolean | undefined | null): Query
    count(): Query
    rerank(options?: RerankOptions | undefined | null): Query
  }
  export class TextExpression {
    static create(expr: TextExpressionUnion): TextExpression
    and(other: TextExpression): TextExpression
    or(other: TextExpression): TextExpression
  }
  export type BinaryOperator =  'and'|
  'or'|
  'eq'|
  'neq'|
  'lt'|
  'lte'|
  'gt'|
  'gte'|
  'startsWith'|
  'contains'|
  'add'|
  'sub'|
  'mul'|
  'div';
  export function bm25Score(): FunctionExpression
  export function field(name: string): LogicalExpression
  export function filter(expr: LogicalExpression | TextExpression): Query
  export type FunctionExpression =
    | { type: 'KeywordScore' }
    | { type: 'VectorScore', field: string, query: QueryVector }
    | { type: 'SemanticSimilarity', field: string, query: string }
  export function literal(value: number | string | boolean): LogicalExpression
  export type LogicalExpressionUnion =
    | { type: 'Null' }
    | { type: 'Field', name: string }
    | { type: 'Literal', value: number | string | boolean }
    | { type: 'Unary', op: UnaryOperator, expr: LogicalExpression }
    | { type: 'Binary', left: LogicalExpression, op: BinaryOperator, right: LogicalExpression }
  export function match(token: string, options?: MatchOptions | undefined | null): TextExpression
  export function not(expr: LogicalExpression): LogicalExpression
  export type QueryVector =
    | { type: 'Dense', query: data.Vector }
    | { type: 'Sparse', query: data.SparseVector }
  export function select(exprs: Record<string, LogicalExpression | FunctionExpression>): Query
  export function semanticSimilarity(field: string, query: string): FunctionExpression
  export interface Term {
    token: string
    field?: string
    weight: number
  }
  export type TextExpressionUnion =
    | { type: 'Terms', all: boolean, terms: Array<Term> }
    | { type: 'And', left: TextExpression, right: TextExpression }
    | { type: 'Or', left: TextExpression, right: TextExpression }
  export type UnaryOperator =  'not'|
  'isNull'|
  'isNotNull';
  export function vectorDistance(field: string, query: Array<number> | data.Vector): FunctionExpression
}

export declare namespace schema {
  export class FieldSpec {
    static create(dataType: DataType): FieldSpec
    required(): FieldSpec
    index(index: FieldIndex): FieldSpec
  }
  export function binaryVector(options: VectorOptions): FieldSpec
  export function bool(): FieldSpec
  export function bytes(): FieldSpec
  export type DataType =
    | { type: 'Text' }
    | { type: 'Integer' }
    | { type: 'Float' }
    | { type: 'Boolean' }
    | { type: 'F32Vector', dimension: number }
    | { type: 'U8Vector', dimension: number }
    | { type: 'BinaryVector', dimension: number }
    | { type: 'F32SparseVector' }
    | { type: 'U8SparseVector' }
    | { type: 'Bytes' }
  export type EmbeddingDataType =  'float32'|
  'uint8'|
  'binary';
  export function f32SparseVector(): FieldSpec
  export function f32Vector(options: VectorOptions): FieldSpec
  export interface FieldIndex {
    index?: FieldIndexUnion
  }
  export type FieldIndexUnion =
    | { type: 'KeywordIndex', indexType: KeywordIndexType }
    | { type: 'VectorIndex', metric: VectorDistanceMetric }
    | { type: 'SemanticIndex', model?: string, embeddingType?: EmbeddingDataType }
  export function float(): FieldSpec
  export function int(): FieldSpec
  export function keywordIndex(): FieldIndex
  export type KeywordIndexType =  'text';
  export function semanticIndex(options?: SemanticIndexOptions | undefined | null): FieldIndex
  export interface SemanticIndexOptions {
    model?: string
    embeddingType?: EmbeddingDataType
  }
  export function text(): FieldSpec
  export function u8SparseVector(): FieldSpec
  export function u8Vector(options: VectorOptions): FieldSpec
  export type VectorDistanceMetric =  'cosine'|
  'euclidean'|
  'dot_product'|
  'hamming';
  export function vectorIndex(options: VectorIndexOptions): FieldIndex
  export interface VectorIndexOptions {
    metric: VectorDistanceMetric
  }
  export interface VectorOptions {
    dimension: number
  }
}
